<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>浏览器工作原理&nbsp;|&nbsp;Notablog</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="浏览器工作原理">
  
  
    <meta property="og:image" content="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;🕷️&lt;/text&gt;&lt;/svg&gt;">
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>About</span>
        </div>
      </a>
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
      <div class="Header__Icon">
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;🕷️&lt;/text&gt;&lt;/svg&gt;"></span>
      </div>
    
    <h1 class="Header__Title">浏览器工作原理</h1>
    
      <div class="DateTagBar">
        
          <span class="DateTagBar__Item DateTagBar__Date">Posted on Sun, Apr 10, 2022</span>
        
        
      </div>
    
  </header>
  <article id="https://www.notion.so/cd84a0953f5d4e4daabd59f84350f6cf" class="PageRoot PageRoot--FullWidth"><ul id="https://www.notion.so/bafb7673ac4c43b5a3f3555806c9594d" class="ColorfulBlock ColorfulBlock--ColorGray TableOfContents"><li class="TableOfContents__Item"><a href="#https://www.notion.so/f7ffa3d413d74989a05ce1e06786ace9"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Chrome架构：仅仅打开了1个页面，为什么有4个进程？</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/8606d3745e0d479fb97059537d83a658"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">进程和线程</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/817a122f3df8439ea2ad58728f9c1708"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">进程和线程关系的特点</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/5768056efad34f9eab70edfbc7382c4a"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">单进程浏览器</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/49bab3a0abc54dc29fbcc227f3141f55"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">多进程浏览器</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/b7615d8cd4a54453ab25f8d25d45227c"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">2008年Chrome的多进程架构</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/2350b3b43f2c47f9b0ad177a68dc3b00"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">最新的Chrome进程架构图</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/582749b6c1744dd5a4a3ba97b30e82bb"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">多进程浏览器缺点</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/24fd798e15c74744aaefae23dee85dd0"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">未来面向服务的架构</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/cb1f691382164ae891da2edbbcd67ead"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">面向服务的架构图</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/192fcd3e6b8d4404b17279a127cbd4f2"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">为什么多进程架构中依然由于单个页面卡死导致全部页面崩溃？</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/22c94f2cce42469b8bd19730b240d359"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">TCP协议</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/d2dd2d6fcb524317bc18b0d56ea56fe7"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">一个数据包的“旅程”</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/8392e7bf9b1a464e94102a5da3356818"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">1. </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">IP：把数据包送达目的主机</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/c142a12633f042ebabb5a26265b777e8"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">2. </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">UDP：把数据包送达应用程序</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/0f00f43022584cc192bdda1470bf33d3"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">3. </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">TCP：把数据完整地送达应用程序</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/2c7e1fe93a204642b96924aef2fa17af"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">HTTP请求流程</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/07a19cbaef1c4f00a46089441bd9f7b1"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">浏览器端发起HTTP请求流程</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/2861c2f627b04e93811874296ed9b2e7"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString">1. 构建请求</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/6ff28f28945a47078f47a37a300669e7"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString">2. 查找缓存</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/04b2a3a0a7894043b9e86741922a10b9"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString">3. 准备IP地址和端口</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/e24daed34ff64225baef259dc4f5890f"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString">4. 等待TCP队列</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/e274c32312b1485eb6291a56514562f9"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">5. 建立 TCP 连接</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/71a17b7dc848439e82e9712870bef5f0"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString">6. 发送HTTP请求</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/f89873e86c0b4bbca95a726472843fe6"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">服务器端处理 HTTP 请求流程</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/a9a3a40b572b4d6e817972d5a360b131"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString">1. 返回请求</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/ac84b12726a34ebcbf5b25e35df9ded2"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString">2. 断开连接</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/8c654e1933e645fb81eceaf35169ac9e"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString">3. 重定向</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/1a537c3d9d764e66accbe933623a2eb1"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1. 为什么很多站点第二次打开速度会很快？</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/b4059c3bcd094c9a88eb1fbc0d405904"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2. 登录状态是如何保持的？</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/4ca84319a6a54ff9a2d9ceb1c51f57da"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">导航流程：</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">从输入URL到页面展示，这中间发生了什么？</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/4bd4f7a93dad46d8b518401616adea11"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1. 用户输入</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/4c201390f6774b958a57dafa4e6f0c5f"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2. URL 请求过程</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/d50edf365b3e449fb649cb038ea30c08"><div style="margin-left:96px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">（1）重定向</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/61709d2f416c40a8a241533611241c0e"><div style="margin-left:96px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">（2）响应数据类型处理</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/213a5bd9597e4f03a425b4865ea43973"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">3. 准备渲染进程</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/e9a8aea423f345928547eca763bf3d95"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">4. 提交文档</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/52d9ba77745c40c18e9fd19964b9d402"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString">5. 渲染节点</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/482302f1d9f847618ad1411564cc102f"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">渲染流程</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/a82b58fbd5d54a38b7b0b51bee6c1e53"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString">1. DOM+CSSOM ⇒ 布局树</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/55dca33beda44a1d85f9cb1eca96bc85"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2. 布局计算</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/f8116b10fc8e4312a109b4b54fa18d6d"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString">3. 分层</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/7d1af5eba35e460290978132aba2cf8d"><div style="margin-left:96px"><span class="SemanticStringArray"><span class="SemanticString">图层绘制</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/b16e4ef05b1c47ed86d2116ac4777993"><div style="margin-left:96px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">栅格化（raster）操作</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/54e23081f8ec406abeef114706dfa04e"><div style="margin-left:96px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">合成和显示</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/90c60d31db8544c1908c8aea43eae617"><div style="margin-left:96px"><span class="SemanticStringArray"><span class="SemanticString">渲染流水线图示</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/bb361929eba5423c8f3871191be76b46"><div style="margin-left:96px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1. 更新了元素的几何属性（重排）</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/6b39d6c3a6874478992b5c1f175d7199"><div style="margin-left:96px"><span class="SemanticStringArray"><span class="SemanticString">2. 更新元素的绘制属性（重绘）</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/fa5cae3ebd9c45d496b8b1ab6f7f3de3"><div style="margin-left:96px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">3. 直接合成阶段</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/d5c85aeec478467896a11a13e84c5df4"><div style="margin-left:72px"><span class="SemanticStringArray"><span class="SemanticString">作用域</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/67202992e85042ec922a4c94729b63d9"><div style="margin-left:96px"><span class="SemanticStringArray"><span class="SemanticString">块级作用域</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/ed79aa094184466ab6869a18ac5b1e8c"><div style="margin-left:96px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">变量提升</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/52862e0e976b4b32b55ea5c4f8a5ecaa"><div style="margin-left:120px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1. 变量容易在不被察觉的情况下被覆盖掉</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/1bddde5464a14118ae5eee3ad5700f94"><div style="margin-left:120px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2. 本应销毁的变量没有被销毁</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/a128b80587ad47bb8f874031c3706d9e"><div style="margin-left:96px"><span class="SemanticStringArray"><span class="SemanticString">解决变量提升 - let const</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/dba8f1b1e9e2458d98779c7baeb02829"><div style="margin-left:120px"><span class="SemanticStringArray"><span class="SemanticString">js如何支持块级作用域</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/7b51a5dc8aac4571a08da6742cbcfd87"><div style="margin-left:120px"><span class="SemanticStringArray"><span class="SemanticString">暂时性死区</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/f35e024b461142b5968b60ca50b253e5"><div style="margin-left:96px"><span class="SemanticStringArray"><span class="SemanticString">作用域链和闭包</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/9081ae16a4674b04a101aaebc9863670"><div style="margin-left:120px"><span class="SemanticStringArray"><span class="SemanticString">作用域链</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/68475f6dd58c452f84f55e8f0a142687"><div style="margin-left:144px"><span class="SemanticStringArray"><span class="SemanticString">词法作用域</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/7c1ed2e09ae942798769ea29f0206443"><div style="margin-left:120px"><span class="SemanticStringArray"><span class="SemanticString">闭包</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/84f14b3b74754ed8a124a2364cce0000"><div style="margin-left:144px"><span class="SemanticStringArray"><span class="SemanticString">闭包的回收</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/652b884268c44be9aff79e3e4c2a4dac"><div style="margin-left:144px"><span class="SemanticStringArray"><span class="SemanticString">输出什么？触发闭包了吗？</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/5a6a32f1970645f0bd3bc831c266a518"><div style="margin-left:120px"><span class="SemanticStringArray"><span class="SemanticString">this</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/66a00235d03a4da6adb619fadf21018a"><div style="margin-left:120px"><span class="SemanticStringArray"><span class="SemanticString">V8引擎工作原理</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/b8fb3c659c98415482538fc184cd6d29"><div style="margin-left:144px"><span class="SemanticStringArray"><span class="SemanticString">内存如何存储数据</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/20b3012aa7874e209e6dcae304181716"><div style="margin-left:168px"><span class="SemanticStringArray"><span class="SemanticString">再谈闭包</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/214ec3ecaa784b9493e187ed0a19cdc2"><div style="margin-left:144px"><span class="SemanticStringArray"><span class="SemanticString">垃圾回收</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/26798fa4e78c46bba6b1cfcf90a15e8e"><div style="margin-left:168px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">代际假说</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/404e6f4d75a143d18ac32ac7f196632d"><div style="margin-left:168px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">垃圾回收器的工作流程</strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/22dd37a8d3334bfba6eda83a11d428d2"><div style="margin-left:168px"><span class="SemanticStringArray"><span class="SemanticString">副垃圾回收器</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/5727bcfaaa1b415386580526311a1736"><div style="margin-left:168px"><span class="SemanticStringArray"><span class="SemanticString">主垃圾回收器</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/b7047e12d2044129972e55428438c963"><div style="margin-left:168px"><span class="SemanticStringArray"><span class="SemanticString">全停顿</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/ef01be5cf6e84563bf8c355ba0908741"><div style="margin-left:168px"><span class="SemanticStringArray"><span class="SemanticString">你是如何判断 JavaScript 中内存泄漏的？如何避免泄漏？</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/fdabaaa4cd97436e9e4cf1a1e7bec45a"><div style="margin-left:144px"><span class="SemanticStringArray"><span class="SemanticString">v8如何执行js代码</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/859d9e37f4b248f69c18feb4bce5b807"><div style="margin-left:168px"><span class="SemanticStringArray"><span class="SemanticString">编译器和解释器</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/d78f1623bfb545a283f544ebe44552de"><div style="margin-left:168px"><span class="SemanticStringArray"><span class="SemanticString">1. 生成抽象语法树AST和执行上下文</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/032a8414f4af4277b0ed5036920788ab"><div style="margin-left:168px"><span class="SemanticStringArray"><span class="SemanticString">2.生成字节码</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/69729c91f23448bc95568d73b92f979f"><div style="margin-left:168px"><span class="SemanticStringArray"><span class="SemanticString">3.执行代码</span></span></div></a></li></ul><div id="https://www.notion.so/1f08ad4da2304290a2fbc0710766e829" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">,</span></span></p></div><h1 id="https://www.notion.so/f7ffa3d413d74989a05ce1e06786ace9" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/f7ffa3d413d74989a05ce1e06786ace9"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Chrome架构：仅仅打开了1个页面，为什么有4个进程？</strong></span></span></h1><div id="https://www.notion.so/a1102e2af9d84f3a9e27e1be7742f105" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff4d8d414-4c32-48b5-b8e4-91fa0e84fa26%2FUntitled.png?width=1142&amp;table=block&amp;id=a1102e2a-f9d8-4f3a-9e27-e1be7742f105"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff4d8d414-4c32-48b5-b8e4-91fa0e84fa26%2FUntitled.png?width=1142&amp;table=block&amp;id=a1102e2a-f9d8-4f3a-9e27-e1be7742f105" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h2 id="https://www.notion.so/8606d3745e0d479fb97059537d83a658" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/8606d3745e0d479fb97059537d83a658"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">进程和线程</span></span></h2><div id="https://www.notion.so/33f89bd1fa9b4f99be06907e6bc9d826" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">多线程可以并行处理任务，但是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">线程是不能单独存在的，它是由进程来启动和管理的</strong></span><span class="SemanticString">。那什么又是进程呢？</span></span></p></div><div id="https://www.notion.so/d706983d8f7a436b83bbcc258a97f192" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">一个进程就是一个程序的运行实例</strong></span><span class="SemanticString">。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">进程</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/418ccd405c884031afcc0c1bbf642a9d" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9b31bff8-7e44-4b14-91d7-2aa615ba5bd3%2FUntitled.png?width=1142&amp;table=block&amp;id=418ccd40-5c88-4031-afcc-0c1bbf642a9d"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9b31bff8-7e44-4b14-91d7-2aa615ba5bd3%2FUntitled.png?width=1142&amp;table=block&amp;id=418ccd40-5c88-4031-afcc-0c1bbf642a9d" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/c42418f8616340c3b2f2be59f33e86a4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/c4c027ebf74e4e588d739c28489ab997" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/817a122f3df8439ea2ad58728f9c1708" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/817a122f3df8439ea2ad58728f9c1708"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">进程和线程关系的特点</span></span></h3><ol class="NumberedListWrapper"><li id="https://www.notion.so/a0bbdf2b8f4b40a493a64b3eb41a4246" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></span></span></li><li id="https://www.notion.so/9219fdc3c47d4b7481d60546eb33da74" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">线程之间共享进程中的数据。</strong></span></span><div id="https://www.notion.so/01fcce6dadb54b71b7c7102d45e6a582" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">线程之间可以对进程的公共数据进行读写操作。</span></span></p></div><div id="https://www.notion.so/56a3e1e76472409fa8b2b4349fca2f5b" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd4d5abbc-bb46-4a20-8cc4-e3b1dcc61b59%2FUntitled.png?width=1142&amp;table=block&amp;id=56a3e1e7-6472-409f-a8b2-b4349fca2f5b"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd4d5abbc-bb46-4a20-8cc4-e3b1dcc61b59%2FUntitled.png?width=1142&amp;table=block&amp;id=56a3e1e7-6472-409f-a8b2-b4349fca2f5b" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/3cc5671e435a435d9991c7c7319eeb4e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 A、B、C 中，然后线程 2 继续从 A、B、C 中读取数据，用来显示执行结果。</span></span></p></div></li><li id="https://www.notion.so/d94155b17c734b6b969a1f4b504099e3" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">当一个进程关闭之后，操作系统会回收进程所占用的内存。</strong></span></span><div id="https://www.notion.so/0d038a5583574257bda114c70f086517" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</span></span></p></div></li><li id="https://www.notion.so/e0bb6b8f9d084a76a214825d53ded6a7" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">进程之间的内容相互隔离。</strong></span></span><div id="https://www.notion.so/931c3f51e2a0466b8f5d950dc97d232f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。</span></span></p></div><div id="https://www.notion.so/34bde14c6d714bc0af297ff03e375cb5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果进程之间需要进行数据的通信，这时候，就需要使用用于</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">进程间通信</code></span><span class="SemanticString">（IPC）的机制了。</span></span></p></div></li></ol><div id="https://www.notion.so/7c5e102b68c440d3852f3ccbb4a0401a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/5768056efad34f9eab70edfbc7382c4a" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/5768056efad34f9eab70edfbc7382c4a"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">单进程浏览器</span></span></h2><div id="https://www.notion.so/eb0eab0b61894d9c9188ed0d6e626cb4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里</strong></span><span class="SemanticString">，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。</span></span></p></div><div id="https://www.notion.so/e91d456596c2425d8d9d3090e741f3a0" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1d1b2621-f20f-43e1-9ca7-7e3cb28ddf2a%2FUntitled.png?width=1142&amp;table=block&amp;id=e91d4565-96c2-425d-8d9d-3090e741f3a0"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1d1b2621-f20f-43e1-9ca7-7e3cb28ddf2a%2FUntitled.png?width=1142&amp;table=block&amp;id=e91d4565-96c2-425d-8d9d-3090e741f3a0" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/d2add0dc2cc642d99fc2a482f7afa326" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如此多的功能模块运行在一个进程里，导致单进程浏览器</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">不稳定</strong></span><span class="SemanticString">、</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">不流畅</strong></span><span class="SemanticString">和</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">不安全</strong></span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/a3bb30e85cc645ab91f42d56e3e3e219" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">不稳定</strong></span></span></li></ol><div id="https://www.notion.so/522576f104694d77beda690d91d2dca9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">早期浏览器需要借助于</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">插件</strong></span><span class="SemanticString">来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。</span></span></p></div><div id="https://www.notion.so/94bf69be13ff479cbb293ce14babd287" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">除了插件之外，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">渲染引擎模块</strong></span><span class="SemanticString">也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/5fc24ff1a96743c7a07b3279f6e33771" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">不流畅</strong></span></span></li></ol><div id="https://www.notion.so/a458277b3f64407fa55f61098813a425" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。</span></span></p></div><div id="https://www.notion.so/2890c20362c64c728167153f5c3eeab6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">页面的内存泄漏</strong></span><span class="SemanticString">也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/d09f4a05e30d46c48c4c77e6e710a482" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">不安全</strong></span></span></li></ol><div id="https://www.notion.so/ea4eaa19091942c08c6c2be88bfc9afd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</span></span></p></div><div id="https://www.notion.so/70f24dfc932849869ea9cd41cf1ed991" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</span></span></p></div><div id="https://www.notion.so/78c5a56ef3dd4e2e8950024f69526cbc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/49bab3a0abc54dc29fbcc227f3141f55" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/49bab3a0abc54dc29fbcc227f3141f55"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">多进程浏览器</span></span></h2><h3 id="https://www.notion.so/b7615d8cd4a54453ab25f8d25d45227c" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/b7615d8cd4a54453ab25f8d25d45227c"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">2008年Chrome的多进程架构</span></span></h3><div id="https://www.notion.so/a5fd1e50b67b41bfa2ec1f429577670e" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7684cb0c-57e4-43fc-9208-81ed4c0032c7%2FUntitled.png?width=1142&amp;table=block&amp;id=a5fd1e50-b67b-41bf-a2ec-1f429577670e"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7684cb0c-57e4-43fc-9208-81ed4c0032c7%2FUntitled.png?width=1142&amp;table=block&amp;id=a5fd1e50-b67b-41bf-a2ec-1f429577670e" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/2b9dbe1287a34f449ebc1628ad3215dd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信</span></span></p></div><div id="https://www.notion.so/b4db498e164d4601ac978e3614b07a0f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/8db04a1f71af4e99b07bc63eed98d735" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">解决不稳定的问题。</strong></span><span class="SemanticString">由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面</span></span></li><li id="https://www.notion.so/5e9a45537588469a9d0b90a1d693f1f4" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为</span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedBg SemanticString__Fragment--BgRed"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">其他页面的脚本是运行在它们自己的渲染进程中的</strong></mark></span><span class="SemanticString">。所以当我们再在 Chrome 中运行死循环的脚本时，没有响应的仅仅是当前的页面。</span></span></li><li id="https://www.notion.so/a9627a18eab640f89b6fcd98c9dc374b" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">采用多进程架构的额外好处是可以使用</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">安全沙箱</strong></span><span class="SemanticString">，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据</span></span></li></ol><div id="https://www.notion.so/18207bb4ae7a43159776c3e7e444e393" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/2350b3b43f2c47f9b0ad177a68dc3b00" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/2350b3b43f2c47f9b0ad177a68dc3b00"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">最新的Chrome进程架构图</span></span></h3><div id="https://www.notion.so/7d6935a57e264ac888b7a92020ed3563" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8ffd4d03-82f3-4af1-bccb-3945106da2c1%2FUntitled.png?width=1142&amp;table=block&amp;id=7d6935a5-7e26-4ac8-88b7-a92020ed3563"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8ffd4d03-82f3-4af1-bccb-3945106da2c1%2FUntitled.png?width=1142&amp;table=block&amp;id=7d6935a5-7e26-4ac8-88b7-a92020ed3563" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/b30401a6c77a4220adecbed73a96dea6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/586e8b44faae44b696963f61ccff284d" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">浏览器进程</strong></span><span class="SemanticString">。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</span></span></li><li id="https://www.notion.so/2381527d0bec4c59872643051d848dad" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">渲染进程</strong></span><span class="SemanticString">。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">排版引擎 Blink</code></span><span class="SemanticString"> 和</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"> JavaScript 引擎 V8</code></span><span class="SemanticString"> 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</span></span></li><li id="https://www.notion.so/f043f8b0f7824bb3862d7cf74b823fd8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">GPU 进程</strong></span><span class="SemanticString">。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorRed"> UI 界面都选择采用 GPU 来绘制</mark></strong></span><span class="SemanticString">，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</span></span></li><li id="https://www.notion.so/615da24aca8f457989e51ea6d1a9235e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">网络进程</strong></span><span class="SemanticString">。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</span></span></li><li id="https://www.notion.so/c9d77f8a0fc941e4bdc48d641b249ff8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">插件进程</strong></span><span class="SemanticString">。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</span></span></li></ul><div id="https://www.notion.so/06164e7166f04964be2f299ac52ca4a3" class="ColorfulBlock ColorfulBlock--BgRed Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedBg SemanticString__Fragment--BgRed">上面的内容回答了为什么打开一个页面有四个进程</mark></span></span></p></div><h3 id="https://www.notion.so/582749b6c1744dd5a4a3ba97b30e82bb" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/582749b6c1744dd5a4a3ba97b30e82bb"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">多进程浏览器缺点</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/7d51c1e4a52b482e9b82c6d5bba5a826" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">更高的资源占用</strong></span><span class="SemanticString">。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</span></span></li><li id="https://www.notion.so/e5fe775f42db40018bd1acc7b8255f0e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">更复杂的体系架构</strong></span><span class="SemanticString">。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</span></span></li></ul><div id="https://www.notion.so/05a78babf61448aea52228b672cb1414" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/168cabb11cbf435ba8f3218cd3894ae5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/24fd798e15c74744aaefae23dee85dd0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/24fd798e15c74744aaefae23dee85dd0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">未来面向服务的架构</strong></span></span></h2><div id="https://www.notion.so/20f2638b8e6b4ef78f12631b7b0ae91c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">为了解决这些问题，在 2016 年，Chrome 官方团队使用“</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">面向服务的架构</strong></span><span class="SemanticString">”（Services Oriented Architecture，简称</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">SOA</strong></span><span class="SemanticString">）的思想设计了新的 Chrome 架构。原来的各种模块会被重构成独立的服务（Service），每个服务都可以在独立的进程中运行，访问服务必须使用定义好的接口，通过 IPC 来通信，从而</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">构建一个更内聚、松耦合、易于维护和扩展的系统</strong></span><span class="SemanticString">，更好实现 Chrome 简单、稳定、高速、安全的目标</span></span></p></div><h3 id="https://www.notion.so/cb1f691382164ae891da2edbbcd67ead" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/cb1f691382164ae891da2edbbcd67ead"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">面向服务的架构图</span></span></h3><div id="https://www.notion.so/87ffb72805ca4d48bede93200458ba67" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F671a854b-b9aa-42e0-ab42-065cf9accc0d%2FUntitled.png?width=1142&amp;table=block&amp;id=87ffb728-05ca-4d48-bede-93200458ba67"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F671a854b-b9aa-42e0-ab42-065cf9accc0d%2FUntitled.png?width=1142&amp;table=block&amp;id=87ffb728-05ca-4d48-bede-93200458ba67" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/96735eec0af4446b9e1e44e8be1e51fa" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。</span></span></p></div><div id="https://www.notion.so/e61340b93ca441e482b89ad2726f4b9b" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fcfec7991-dfb1-40cf-b322-547fca4c43fd%2FUntitled.png?width=1142&amp;table=block&amp;id=e61340b9-3ca4-41e4-82b8-9ad2726f4b9b"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fcfec7991-dfb1-40cf-b322-547fca4c43fd%2FUntitled.png?width=1142&amp;table=block&amp;id=e61340b9-3ca4-41e4-82b8-9ad2726f4b9b" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h2 id="https://www.notion.so/192fcd3e6b8d4404b17279a127cbd4f2" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/192fcd3e6b8d4404b17279a127cbd4f2"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">为什么多进程架构中依然由于单个页面卡死导致全部页面崩溃？</span></span></h2><div id="https://www.notion.so/0da83e47d36c4027a75eb1c1d51b6649" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">通常情况下是一个页面使用一个进程，但是，有一种情况，叫&quot;</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">同一站点(same-site)</code></span><span class="SemanticString">&quot;，具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：</span></span></p></div><div id="https://www.notion.so/3d6bf15575fb4f669aa3a0453159a66c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">https://time.geekbang.org</span></span></p></div><div id="https://www.notion.so/4fe4afb5b0b641018e1549e5e4f58388" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">https://www.geekbang.org</span></span></p></div><div id="https://www.notion.so/6014165fd5c3407ab4fe35ad055c8a7f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">https://www.geekbang.org:8080</span></span></p></div><div id="https://www.notion.so/6e34871e0f1b4a1884d5b032f3be7cae" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">都是属于同一站点，因为它们的协议都是https，而根域名也都是geekbang.org。你也许了解同源策略，但是同一站点和同源策略还是存在一些不同地方，在这里你需要了解它们不是同一件事就行了。</span></span></p></div><div id="https://www.notion.so/d16bd25e5a454f4abbc72f9246bd8c87" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedBg SemanticString__Fragment--BgPink">渲染进程</mark></strong></span><span class="SemanticString">。官方把这个默认策略叫</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">process-per-site-instance</code></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/e504ecebed494104bdeb488b6bb2ddc2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">直白的讲，就是如果几个页面符合同一站点，那么他们将被分配到一个渲染进程里面去。</span></span></p></div><div id="https://www.notion.so/6ec9834239f34c64b266b344e9ddcc01" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">所以，这种情况下，一个页面崩溃了，会导致同一站点的页面同时崩溃，因为他们使用了同一个渲染进程。</span></span></p></div><div id="https://www.notion.so/7ca12058905045e2a65cda3843e33452" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">为什么要让他们跑在一个进程里面呢？</span></span></p></div><div id="https://www.notion.so/07f0b88dc2d341248566293fab97c53c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">因为在一个渲染进程里面，他们就会共享JS的执行环境，也就是说A页面可以直接在B页面中执行脚本。因为是同一家的站点，所以是有这个需求的。</span></span></p></div><div id="https://www.notion.so/172be43fe6214595922e57db80c11c2f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/86ce661830b342d49bb6130ab435f05d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/22c94f2cce42469b8bd19730b240d359" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/22c94f2cce42469b8bd19730b240d359"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">TCP协议</span></span></h1><div id="https://www.notion.so/514891349c68461ca1fcb4a7adf9787d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在衡量 Web 页面性能的时候有一个重要的指标叫“</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">FP（First Paint）</strong></span><span class="SemanticString">”，是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">指从页面加载到首次开始绘制的时长</strong></span><span class="SemanticString">。这个指标直接影响了用户的跳出率，更快的页面响应意味着更多的 PV、更高的参与度，以及更高的转化率。那什么影响 FP 指标呢？其中一个重要的因素是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">网络加载速度</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/b49a82987e8e45b9bedba7995b09a5ca" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">那么如何保证页面文件能被完整地送达浏览器呢？</strong></span></span></p></div><h2 id="https://www.notion.so/d2dd2d6fcb524317bc18b0d56ea56fe7" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/d2dd2d6fcb524317bc18b0d56ea56fe7"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">一个数据包的“旅程”</strong></span></span></h2><div id="https://www.notion.so/c7dc36e5b1374cd9a195aec3f20e8da7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">下面我将分别从“</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">数据包如何送达主机</code></span><span class="SemanticString">”“</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">主机如何将数据包转交给应用</code></span><span class="SemanticString">”和“</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">数据是如何被完整地送达应用程序</code></span><span class="SemanticString">”这三个角度来为你讲述数据的传输过程。</span></span></p></div><div id="https://www.notion.so/dfd37ea5d8c942e1b64886d5f235e51e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。比如你现在听的音频数据，是拆分成一个个小的数据包来传输的，并不是一个大的文件一次传输过来的。</span></span></p></div><h3 id="https://www.notion.so/8392e7bf9b1a464e94102a5da3356818" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/8392e7bf9b1a464e94102a5da3356818"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">1. </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">IP：把数据包送达目的主机</strong></span></span></h3><div id="https://www.notion.so/30e7b070243f43df948d3563b46178c9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">数据包要在互联网上进行传输，就要符合</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">网际协议</strong></span><span class="SemanticString">（Internet Protocol，简称</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">IP</strong></span><span class="SemanticString">）标准</span></span></p></div><div id="https://www.notion.so/d2cf4f4e927f4d5fbb5bb55fe83ad44e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。</span></span></p></div><h3 id="https://www.notion.so/c142a12633f042ebabb5a26265b777e8" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/c142a12633f042ebabb5a26265b777e8"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">2. </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">UDP：把数据包送达应用程序</strong></span></span></h3><div id="https://www.notion.so/1fa4e883d8bd4e3b8610c7708772740c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">IP 是非常底层的协议，</span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedBg SemanticString__Fragment--BgRed">只负责把数据包传送到对方电脑</mark></span><span class="SemanticString">，但是对方电脑并不知道把数据包交给哪个程序，是交给浏览器还是交给王者荣耀？因此，</span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedBg SemanticString__Fragment--BgRed">需要基于 IP 之上开发能和应用打交道的协议</mark></span><span class="SemanticString">，最常见的是“</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">用户数据包协议</strong></span><span class="SemanticString">（User Datagram Protocol）”，简称</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">UDP</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/77c086ffc04b431a9b1202436f098e21" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">UDP 中一个最重要的信息是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">端口号</strong></span><span class="SemanticString">，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序</strong></span><span class="SemanticString">。和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。</span></span></p></div><div id="https://www.notion.so/f2a1ef88c3834d4985b1f4507ce7bbf0" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F42df6c6d-be44-4309-a519-5331f75fca5a%2FUntitled.png?width=1142&amp;table=block&amp;id=f2a1ef88-c383-4d49-85b1-f4507ce7bbf0"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F42df6c6d-be44-4309-a519-5331f75fca5a%2FUntitled.png?width=1142&amp;table=block&amp;id=f2a1ef88-c383-4d49-85b1-f4507ce7bbf0" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/4828206faecd4d58b8185b8db449b718" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。</span></span></p></div><div id="https://www.notion.so/de265fbfb9fa4938a1e59af8bf1e748b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">UDP 不能保证数据可靠性，但是传输速度却非常快</strong></span><span class="SemanticString">，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。</span></span></p></div><div id="https://www.notion.so/a8292e93d22c46aeaced4a8849ac2a53" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">使用 UDP 来传输会存在</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">两个问题</strong></span><span class="SemanticString">：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/340594a6882f493281e9839b6f351b1c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">数据包在传输过程中容易丢失；</span></span></li><li id="https://www.notion.so/91e649672cc54522bef465f3b7fa457a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。</span></span></li></ul><h3 id="https://www.notion.so/0f00f43022584cc192bdda1470bf33d3" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/0f00f43022584cc192bdda1470bf33d3"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">3. </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">TCP：把数据完整地送达应用程序</strong></span></span></h3><div id="https://www.notion.so/07ca6c9eef044b5ca9ed94e5959c69aa" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议</strong></span><span class="SemanticString">。</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/9576303b99cb4e79816b6a6ecae74e6b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">对于数据包丢失的情况，TCP 提供重传机制；</span></span></li><li id="https://www.notion.so/f243d20d199342cf9046b297d2c63cb8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。</span></span></li></ul><div id="https://www.notion.so/39bbfacb86ee4ced90f4db8ee564e14f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">完整的 TCP 连接过程</strong></span></span></p></div><div id="https://www.notion.so/3c3f12e49c6b45aa9877857d0aaa1a83" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一个完整的 TCP 连接的生命周期包括了“</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">建立连接</strong></span><span class="SemanticString">”“</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">传输数据</strong></span><span class="SemanticString">”和“</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">断开连接</strong></span><span class="SemanticString">”三个阶段。</span></span></p></div><div id="https://www.notion.so/2c3667b407ae4b4fbbe743a87b32571f" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6b6755d8-d507-464f-bd4e-55203c6597f5%2FUntitled.png?width=1142&amp;table=block&amp;id=2c3667b4-07ae-4b4f-bbe7-43a87b32571f"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6b6755d8-d507-464f-bd4e-55203c6597f5%2FUntitled.png?width=1142&amp;table=block&amp;id=2c3667b4-07ae-4b4f-bbe7-43a87b32571f" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/6d802d59b3d847f2ba1c771a4f978650" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">首先，建立连接阶段</strong></span><span class="SemanticString">。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">面向连接</strong></span><span class="SemanticString">是指在数据通信开始之前先做好两端之间的准备工作。所谓</span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorRed"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">三次握手</strong></mark></span><span class="SemanticString">，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。</span></span></li><li id="https://www.notion.so/ce057c2bec9144febd2f416f2437c618" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">其次，传输数据阶段</strong></span><span class="SemanticString">。在该阶段，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">接收端需要对每个数据包进行确认操作</strong></span><span class="SemanticString">，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。</span></span></li><li id="https://www.notion.so/90edeb05be114ff297c4f4428d2e17f0" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">最后，断开连接阶段</strong></span><span class="SemanticString">。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorRed">四次挥手</mark></strong></span><span class="SemanticString">”来保证双方都能断开连接。</span></span></li></ul><div id="https://www.notion.so/44e0cf0d59a2401f8611f923dd3f323d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/2c7e1fe93a204642b96924aef2fa17af" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/2c7e1fe93a204642b96924aef2fa17af"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">HTTP请求流程</span></span></h1><div id="https://www.notion.so/7701aaef00d2454d830dba00632b1878" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">HTTP 协议，正是建立在 TCP 连接基础之上的。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础</strong></span><span class="SemanticString">，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">HTTP 也是浏览器使用最广的协议</strong></span></span></p></div><div id="https://www.notion.so/9b922aad5f1146f0808185d9b4b3c9be" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/9b1e5deea3934a99b83763737cfed752" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">为什么通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快了？</span></span></li><li id="https://www.notion.so/d9ed3a9e01224b8a9265984384bc5eaf" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">当登录过一个网站之后，下次再访问该站点，就已经处于登录状态了，这是怎么做到的呢？</span></span></li></ol><div id="https://www.notion.so/fba729f9b16e44c58c6af5e6b2a036b1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/07a19cbaef1c4f00a46089441bd9f7b1" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/07a19cbaef1c4f00a46089441bd9f7b1"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">浏览器端发起HTTP请求流程</span></span></h2><div id="https://www.notion.so/4f616781b6f94043a58ead6c1ff7fda5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在浏览器地址栏中键入网址，浏览器有如下操作</span></span></p></div><h3 id="https://www.notion.so/2861c2f627b04e93811874296ed9b2e7" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/2861c2f627b04e93811874296ed9b2e7"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">1. 构建请求</span></span></h3><div id="https://www.notion.so/1b76081fe83f464891300f76105562c5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">首先，浏览器构建</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">请求行</strong></span><span class="SemanticString">信息（如下所示），构建好后，浏览器准备发起网络请求。</span></span></p></div><div id="https://www.notion.so/d7716920ce0b4f4796e5649faff5dd08" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">GET /index.html HTTP1.1</code></span></span></p></div><div id="https://www.notion.so/3399c18724e54689907f61174ef83827" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/6ff28f28945a47078f47a37a300669e7" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/6ff28f28945a47078f47a37a300669e7"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">2. 查找缓存</span></span></h3><div id="https://www.notion.so/71e297ca7ce14fd2bc59a0846626a976" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/05414cd42d4a4cbf9f8f04b200afee3b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/52b9c5d7057c47819385e060be14434c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">缓解服务器端压力，提升性能（获取资源的耗时更短了）；</span></span></li><li id="https://www.notion.so/d049c9ebc22c438bbb37be4d188a063e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">对于网站来说，缓存是实现快速资源加载的重要组成部分。</span></span></li></ul><div id="https://www.notion.so/c8396b07f1de43c1b52c014f903ddd59" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当然，如果缓存查找失败，就会进入网络请求过程了。</span></span></p></div><div id="https://www.notion.so/2e6a76b4dc6d45e286f9516bc3709c76" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/04b2a3a0a7894043b9e86741922a10b9" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/04b2a3a0a7894043b9e86741922a10b9"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">3. 准备IP地址和端口</span></span></h3><div id="https://www.notion.so/a2ef9fdd61ce4902a81e0b07abac184d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">因为浏览器使用</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">HTTP 协议作为应用层协议</strong></span><span class="SemanticString">，用来封装请求的文本信息；并使用</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">TCP/IP 作传输层协议</strong></span><span class="SemanticString">将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">HTTP 的内容是通过 TCP 的传输数据阶段来实现的</strong></span></span></p></div><div id="https://www.notion.so/669e39aea6134a7184950657c93810d6" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc965bcda-af26-4491-99eb-d9056b0c9d7d%2FUntitled.png?width=1142&amp;table=block&amp;id=669e39ae-a613-4a71-8495-0657c93810d6"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc965bcda-af26-4491-99eb-d9056b0c9d7d%2FUntitled.png?width=1142&amp;table=block&amp;id=669e39ae-a613-4a71-8495-0657c93810d6" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/da42b342bf5349bfb9c8ba2959d7f20b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">HTTP 网络请求的第一步是做什么呢？结合上图看，是和服务器建立 TCP 连接。</span></span></li><li id="https://www.notion.so/f0fd42b0cc2a4b6c91d15000de1c5700" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">那建立连接的信息都有了吗？建立 TCP 连接的第一步就是需要准备 IP 地址和端口号。</span></span></li><li id="https://www.notion.so/9ba0f62177a64c6fa317509cdfbd6a9a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">那怎么获取 IP 地址和端口号呢？利用 URL 地址来获取 IP 和端口信息</span></span></li></ul><div id="https://www.notion.so/9de3c805fc5840b4a78d634d303dd258" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">IP地址难以记忆，使用域名来方便记忆，需要将域名和IP地址互相映射的服务，称之为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorRed">DNS</mark></strong></span></span></p></div><div id="https://www.notion.so/dd8c5bead97742eeb07af8e92b43b7d2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">第一步浏览器会请求 DNS 返回域名对应的 IP</strong></span><span class="SemanticString">。当然浏览器还提供了</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">DNS 数据缓存服务</strong></span></span></p></div><div id="https://www.notion.so/29663fb511544f0190cbf54b8d7bd161" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。</span></span></p></div><div id="https://www.notion.so/0bcc2bd9c25841f78e46d2b232da62c8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/e24daed34ff64225baef259dc4f5890f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/e24daed34ff64225baef259dc4f5890f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">4. 等待TCP队列</span></span></h3><div id="https://www.notion.so/a942eee9eaf0429fb0d4514981defe7f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？</span></span></p></div><div id="https://www.notion.so/daff9df2ac0647f2b4e60f290bc8c74d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">答案依然是“不行”。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。</span></span></p></div><div id="https://www.notion.so/5a5d8e036b8d49cda971a32b9bd829e4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。</span></span></p></div><h3 id="https://www.notion.so/e274c32312b1485eb6291a56514562f9" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/e274c32312b1485eb6291a56514562f9"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">5. 建立 TCP 连接</strong></span></span></h3><h3 id="https://www.notion.so/71a17b7dc848439e82e9712870bef5f0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/71a17b7dc848439e82e9712870bef5f0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">6. 发送HTTP请求</span></span></h3><div id="https://www.notion.so/f7a6c468a97141f5ad69d7134399ffb9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。</span></span></p></div><div id="https://www.notion.so/e2b0b71083d744aca445c878fdfe9aca" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1e3507d1-bd52-4f96-b206-5f4016b1a65f%2FUntitled.png?width=1142&amp;table=block&amp;id=e2b0b710-83d7-44ac-a445-c878fdfe9aca"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1e3507d1-bd52-4f96-b206-5f4016b1a65f%2FUntitled.png?width=1142&amp;table=block&amp;id=e2b0b710-83d7-44ac-a445-c878fdfe9aca" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/810aed4fad6e4c588bd42f55c0f1a223" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">请求头</strong></span><span class="SemanticString">是把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。</span></span></p></div><div id="https://www.notion.so/59e93bf7e808479582d100360d761802" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/f89873e86c0b4bbca95a726472843fe6" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/f89873e86c0b4bbca95a726472843fe6"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">服务器端处理 HTTP 请求流程</strong></span></span></h2><h3 id="https://www.notion.so/a9a3a40b572b4d6e817972d5a360b131" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/a9a3a40b572b4d6e817972d5a360b131"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">1. 返回请求</span></span></h3><div id="https://www.notion.so/09a2fc9920824cafbea58bd0699e972a" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe174b373-c017-4132-8e24-6e37d3a4247b%2FUntitled.png?width=1142&amp;table=block&amp;id=09a2fc99-2082-4caf-bea5-8bd0699e972a"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe174b373-c017-4132-8e24-6e37d3a4247b%2FUntitled.png?width=1142&amp;table=block&amp;id=09a2fc99-2082-4caf-bea5-8bd0699e972a" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/6574f2aed07a444abf541d570eb2ac07" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">响应头</strong></span><span class="SemanticString">包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。</span></span></p></div><div id="https://www.notion.so/c51e5c7a6b5247948617c08acf23b9e5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">响应体</strong></span><span class="SemanticString">通常就包含了 HTML 的实际内容。</span></span></p></div><h3 id="https://www.notion.so/ac84b12726a34ebcbf5b25e35df9ded2" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/ac84b12726a34ebcbf5b25e35df9ded2"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">2. 断开连接</span></span></h3><div id="https://www.notion.so/2629b37de4fa47a4bf105ec4381e9692" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Connection:Keep-Alive</code></span><span class="SemanticString">  那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度</strong></span><span class="SemanticString">。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。</span></span></p></div><h3 id="https://www.notion.so/8c654e1933e645fb81eceaf35169ac9e" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/8c654e1933e645fb81eceaf35169ac9e"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">3. 重定向</span></span></h3><div id="https://www.notion.so/d9bfa8a6d0fc4c4fa448c9433a4e06dc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">比如当你在浏览器中打开 geekbang.org 后，你会发现最终打开的页面地址是 </span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://www.geekbang.org/">https://www.geekbang.org</a></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/51bf7609080949faadd5efb8dd8e556c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这两个 URL 之所以不一样，是因为涉及到了一个</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">重定向操作</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/ab62b4f725954ab4bc6ed37320c93ebd" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0122045a-37d6-4518-bf08-7b6e0760d72f%2FUntitled.png?width=1142&amp;table=block&amp;id=ab62b4f7-2595-4ab4-bc6e-d37320c93ebd"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0122045a-37d6-4518-bf08-7b6e0760d72f%2FUntitled.png?width=1142&amp;table=block&amp;id=ab62b4f7-2595-4ab4-bc6e-d37320c93ebd" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/1fa58a15f1f54a399a4dd1efef73aaf3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">重定向操作是服务器的处理手段，如果某网站服务器没有该操作，则不会补全url</span></span></p></div><div id="https://www.notion.so/c0a1b4291226445b970ab50764a66136" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/a95422241d3d4f369fb7ac71adfe20d9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/1a537c3d9d764e66accbe933623a2eb1" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/1a537c3d9d764e66accbe933623a2eb1"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1. 为什么很多站点第二次打开速度会很快？</strong></span></span></h3><div id="https://www.notion.so/5080403ad77d4bc4b06bb8558d4f89d4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">域名被DNS解析后的ip被缓存</span></span></p></div><div id="https://www.notion.so/c5c08423345b430a9df15f0e18c31337" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F033778d8-b35b-4af2-8c39-9f2c13213b06%2FUntitled.png?width=1142&amp;table=block&amp;id=c5c08423-345b-430a-9df1-5f0e18c31337"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F033778d8-b35b-4af2-8c39-9f2c13213b06%2FUntitled.png?width=1142&amp;table=block&amp;id=c5c08423-345b-430a-9df1-5f0e18c31337" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/334178f699084f19aba18184d4320011" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">当服务器返回</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">HTTP 响应头</strong></span><span class="SemanticString">给浏览器时，浏览器是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">通过响应头中的 Cache-Control 字段来设置是否缓存该资源</strong></span><span class="SemanticString">。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。</span></span></li><li id="https://www.notion.so/2d0620e39eeb4a4b9fe323644407721a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果缓存过期了，浏览器则会继续发起网络请求，并且在</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">HTTP 请求头</strong></span><span class="SemanticString">中带上</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">If-None-Match:&quot;4f80f-13c-3a1xb12a&quot;</code></span><span class="SemanticString">，服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/f46239051fb84e29b258ff62f85f9d4f" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”</span></span></li><li id="https://www.notion.so/2cfc9fd5e17a448da4099f7ed5668d4d" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果资源有更新，服务器就直接返回最新资源给浏览器。</span></span></li></ul></li></ul><h3 id="https://www.notion.so/b4059c3bcd094c9a88eb1fbc0d405904" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/b4059c3bcd094c9a88eb1fbc0d405904"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2. 登录状态是如何保持的？</strong></span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/741017abdbc6470d9c355c84dec424be" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。</span></span></li><li id="https://www.notion.so/6cc19fcb99814392bfaca5bb45019d6d" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Set-Cookie: UID=3431uad;</code></span><span class="SemanticString">，然后把响应头发送给浏览器。</span></span></li><li id="https://www.notion.so/6a2b8a3691d14f189bf382118d84db09" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">UID=3431uad</code></span><span class="SemanticString">保持到本地。</span></span></li><li id="https://www.notion.so/8537e2e330ff4160a680a354ce74d67a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。</span></span></li><li id="https://www.notion.so/7c7e8d8b07104372b742ee1575b06bd4" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">UID=3431uad</code></span><span class="SemanticString">的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。</span></span></li><li id="https://www.notion.so/20ebf7b4a12b4fa2a5fa72eff237f5d3" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。</span></span></li></ul><div id="https://www.notion.so/19964442a8fb4c34a4627993f4af1838" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/1f9d74ebfee44d85881bbd6a1b3e8438" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/4ca84319a6a54ff9a2d9ceb1c51f57da" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/4ca84319a6a54ff9a2d9ceb1c51f57da"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">导航流程：</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">从输入URL到页面展示，这中间发生了什么？</strong></span></span></h1><div id="https://www.notion.so/4509a97bdaf448b5a57cb52f95ebc519" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fce7458cd-0b88-4856-9fa6-04fee6f58924%2FUntitled.png?width=1142&amp;table=block&amp;id=4509a97b-daf4-48b5-a57c-b52f95ebc519"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fce7458cd-0b88-4856-9fa6-04fee6f58924%2FUntitled.png?width=1142&amp;table=block&amp;id=4509a97b-daf4-48b5-a57c-b52f95ebc519" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/7be6b3bbce8e456c94b9d76249a8cbc6" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">首先，用户从浏览器进程里</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">输入请求信息</strong></span><span class="SemanticString">；</span></span></li><li id="https://www.notion.so/2eab85ae3e5b4d068552b1aca3cee5a7" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">然后，网络进程</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">发起 URL 请求</strong></span><span class="SemanticString">；</span></span></li><li id="https://www.notion.so/1ebdf747275642a8bb0a8931801cd20c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">服务器响应 URL 请求之后，浏览器进程就又要开始</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">准备渲染进程</strong></span><span class="SemanticString">了；</span></span></li><li id="https://www.notion.so/8ad7de4732bc4ad78e5dd0db9b0f1f6f" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">渲染进程准备好之后，需要先向渲染进程提交页面数据，我们称之为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">提交文档</strong></span><span class="SemanticString">阶段；</span></span></li><li id="https://www.notion.so/71a2a7d035d9445b9d726f6e51a98dbe" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">渲染进程接收完文档信息之后，便开始</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">解析页面和加载子资源</strong></span><span class="SemanticString">，完成页面的渲染。</span></span></li></ul><div id="https://www.notion.so/c7af84422e5e4123a0506962e9aceb96" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">用户发出 URL 请求到页面开始解析的这个过程，就叫做导航</strong></span></span></p></div><h2 id="https://www.notion.so/4bd4f7a93dad46d8b518401616adea11" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/4bd4f7a93dad46d8b518401616adea11"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1. 用户输入</strong></span></span></h2><div id="https://www.notion.so/8ffb495c496745ac9599f0b482b70e54" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">搜索内容</strong></span><span class="SemanticString">，还是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">请求的 URL</strong></span><span class="SemanticString">。</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/d7f99dac1e324b948fdfcc72a5c650ea" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。</span></span></li><li id="https://www.notion.so/f1ab7ba0685f452186f0ff27f3e8f185" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 </span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://time.geekbang.org/">https://time.geekbang.org</a></span><span class="SemanticString">。</span></span></li><li id="https://www.notion.so/d3a19c7c240746c392e2c9fffcb7c732" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">需要等待提交文档阶段，页面内容才会被替换。</span></span></li></ul><h2 id="https://www.notion.so/4c201390f6774b958a57dafa4e6f0c5f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/4c201390f6774b958a57dafa4e6f0c5f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2. URL 请求过程</strong></span></span></h2><div id="https://www.notion.so/81815f4d55ae45ac9236f137c72384a9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">接下来，便进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。那具体流程是怎样的呢？</span></span></p></div><div id="https://www.notion.so/90aabce1c0c34bcea6b4e7a2fcb4adc0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</span></span></p></div><div id="https://www.notion.so/2319b1a0dff746a78cfa6eab08e25edd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</span></span></p></div><div id="https://www.notion.so/bf10c26baffd4a83921cd33c94d7bb69" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。（为了方便讲述，下面我将服务器返回的响应头和响应行统称为响应头。）</span></span></p></div><h3 id="https://www.notion.so/d50edf365b3e449fb649cb038ea30c08" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/d50edf365b3e449fb649cb038ea30c08"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">（1）重定向</strong></span></span></h3><div id="https://www.notion.so/c9b7848b5cf140d78fe7efd31d5f7fa6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。</span></span></p></div><div id="https://www.notion.so/a8c96cc407c3461583af020cf0cd32e4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">curl -I </code></span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="http://time.geekbang.org/">http://time.geekbang.org/</a></code></span></span></p></div><div id="https://www.notion.so/2fd5188038f641bfa0b0da8fdb1cb054" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">curl -I + URL</code></span><span class="SemanticString">的命令是接收服务器返回的响应头的信息。</span></span></p></div><div id="https://www.notion.so/7e3da0644c834e799557ef44086fc1c3" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc598df18-7087-4855-8df8-b76ae016b44f%2FUntitled.png?width=1142&amp;table=block&amp;id=7e3da064-4c83-4e79-9557-ef44086fc1c3"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc598df18-7087-4855-8df8-b76ae016b44f%2FUntitled.png?width=1142&amp;table=block&amp;id=7e3da064-4c83-4e79-9557-ef44086fc1c3" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/968bb70fbe0543378fde012358166a65" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">curl -I </code></span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://time.geekbang.org/">https://time.geekbang.org/</a></code></span></span></p></div><div id="https://www.notion.so/c7bd2bfd69e84b4f8bf9a531bb65cca8" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2ee26f5c-59c1-4ad0-b512-b3fdb47f7087%2FUntitled.png?width=1142&amp;table=block&amp;id=c7bd2bfd-69e8-4b4f-8bf9-a531bb65cca8"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2ee26f5c-59c1-4ad0-b512-b3fdb47f7087%2FUntitled.png?width=1142&amp;table=block&amp;id=c7bd2bfd-69e8-4b4f-8bf9-a531bb65cca8" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h3 id="https://www.notion.so/61709d2f416c40a8a241533611241c0e" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/61709d2f416c40a8a241533611241c0e"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">（2）响应数据类型处理</strong></span></span></h3><div id="https://www.notion.so/d547ab21232d4a13a525022306dd692f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">URL 请求的数据类型，有时候是一个下载类型，有时候是正常的 HTML 页面，那么浏览器是如何区分它们呢？</span></span></p></div><div id="https://www.notion.so/892e07a3ebd24c4d9774ecb413c809f9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">答案是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Content-Type</code></span><span class="SemanticString">。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型</strong></span><span class="SemanticString">，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</span></span></p></div><div id="https://www.notion.so/b1481d6f18734aecaa50f3959ec6290e" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1987753c-1d9b-4995-baae-be08c89b846e%2FUntitled.png?width=1142&amp;table=block&amp;id=b1481d6f-1873-4aec-aa50-f3959ec6290e"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1987753c-1d9b-4995-baae-be08c89b846e%2FUntitled.png?width=1142&amp;table=block&amp;id=b1481d6f-1873-4aec-aa50-f3959ec6290e" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><pre id="https://www.notion.so/f378acceed654362b3488624d5361530" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>curl <span class="token operator">-</span><span class="token class-name">I</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>res001<span class="token punctuation">.</span>geekbang<span class="token punctuation">.</span>org<span class="token operator">/</span>apps<span class="token operator">/</span>geektime<span class="token operator">/</span>android<span class="token operator">/</span><span class="token number">2.3</span><span class="token number">.1</span><span class="token operator">/</span>official<span class="token operator">/</span>geektime_2<span class="token punctuation">.</span><span class="token number">3.1_20190527</span><span class="token operator">-</span><span class="token number">2136_</span>offical<span class="token punctuation">.</span>apk</span></span></span></code></pre><div id="https://www.notion.so/5277ce33de4346368ffeb98df331685c" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc2b7415f-f902-472e-a15c-278354041194%2FUntitled.png?width=1142&amp;table=block&amp;id=5277ce33-de43-4636-8ffe-b98df331685c"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc2b7415f-f902-472e-a15c-278354041194%2FUntitled.png?width=1142&amp;table=block&amp;id=5277ce33-de43-4636-8ffe-b98df331685c" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/4c93df931a80414eaf23e3c7458ae182" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果 Content-Type 字段的值被浏览器判断为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束</strong></span><span class="SemanticString">。但如果是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">HTML，那么浏览器则会继续进行导航流程</strong></span><span class="SemanticString">。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</span></span></p></div><div id="https://www.notion.so/b3ad74e38f624fa2b4c330a30cc325d6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/213a5bd9597e4f03a425b4865ea43973" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/213a5bd9597e4f03a425b4865ea43973"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">3. 准备渲染进程</strong></span></span></h2><div id="https://www.notion.so/a69679aeb6a64be09d9da1c5c224fc5b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">默认情况下，</span><span class="SemanticString"><em class="SemanticString__Fragment SemanticString__Fragment--Italic"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorRed">Chrome 会为每个页面分配一个渲染进程</mark></strong></em></span><span class="SemanticString">，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，</span><span class="SemanticString"><em class="SemanticString__Fragment SemanticString__Fragment--Italic"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorRed"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">浏览器会让多个页面直接运行在同一个渲染进程中。</strong></mark></em></span></span></p></div><div id="https://www.notion.so/e5e64a0cb2264dccb2bd1469d4165aca" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">比如我从极客时间的首页里面打开了另外一个页面——算法训练营，我们看下图的 Chrome 的任务管理器截图：</span></span></p></div><div id="https://www.notion.so/8b268c56563242798765fec667565c7f" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ffbbc7193-547c-4dff-ac7d-d1dd36e4c8c5%2FUntitled.png?width=1142&amp;table=block&amp;id=8b268c56-5632-4279-8765-fec667565c7f"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ffbbc7193-547c-4dff-ac7d-d1dd36e4c8c5%2FUntitled.png?width=1142&amp;table=block&amp;id=8b268c56-5632-4279-8765-fec667565c7f" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/f99becb29307481bb0dda6c25798f41b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">打开的这三个页面都是运行在同一个渲染进程中，进程 ID 是 23601。</span></span></p></div><div id="https://www.notion.so/71e4b19031a94d8fa2a2587e7acdc262" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">那什么情况下多个页面会同时运行在一个渲染进程中呢？</strong></span></span></p></div><div id="https://www.notion.so/d9b3abd2b3d145c0a3019523848db843" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">同一站点（same-site）</code></span><span class="SemanticString">: 具体地讲，我们将“</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">同一站点</strong></span><span class="SemanticString">”定义为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">根域名</strong></span><span class="SemanticString">（例如，geekbang.org）加上</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">协议</strong></span><span class="SemanticString">（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口。</span></span></p></div><div id="https://www.notion.so/83709c9844f84602bdc78c7646e2fa2c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Chrome 的默认策略是，每个标签对应一个渲染进程。但</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程</strong></span><span class="SemanticString">。官方把这个默认策略叫 process-per-site-instance。</span></span></p></div><div id="https://www.notion.so/a1cdb96170ca4fdd84629d79db7227d7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">总结来说，打开一个新页面采用的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">渲染进程策略</strong></span><span class="SemanticString">就是：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/7e2cc97507984efbb527e0bcc5cbf5e8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">通常情况下，打开新的页面都会使用单独的渲染进程；</span></span></li><li id="https://www.notion.so/ecaa214587e2493ab10479b716cd973b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果从 A 页面打开 B 页面，且 A 和 B 都属于</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">同一站点</strong></span><span class="SemanticString">的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</span></span></li></ul><div id="https://www.notion.so/6cd74b4e5b1640e2915d7e30dd17b10d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</span></span></p></div><div id="https://www.notion.so/8db698cb6243451cb9f1649ff35e3e14" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/e9a8aea423f345928547eca763bf3d95" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/e9a8aea423f345928547eca763bf3d95"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">4. 提交文档</strong></span></span></h2><div id="https://www.notion.so/e9625143bc284c169c8ba26b3b38325e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">首先要明确一点，这里的“文档”是指 URL 请求的响应体数据。</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/d144597d70dd4ee0a13d04019acfa012" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">“提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">管道</strong></span><span class="SemanticString">”。</span></span></li><li id="https://www.notion.so/83554e2ba2784ff1880791fcff4fea7b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">等文档数据传输完成之后，渲染进程会返回“</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">确认提交</strong></span><span class="SemanticString">”的消息给浏览器进程。</span></span></li><li id="https://www.notion.so/a7e4402dca3546af999b25060e90001c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">浏览器进程在收到“确认提交”的消息后，会</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">更新浏览器界面状态</strong></span><span class="SemanticString">，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</span></span></li></ul><div id="https://www.notion.so/3c004dd65878458ca3a97e5f4e3904ec" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9fc782ad-a9b5-4085-a14d-199d9d630137%2FUntitled.png?width=1142&amp;table=block&amp;id=3c004dd6-5878-458c-a3a9-7e5f4e3904ec"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9fc782ad-a9b5-4085-a14d-199d9d630137%2FUntitled.png?width=1142&amp;table=block&amp;id=3c004dd6-5878-458c-a3a9-7e5f4e3904ec" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h2 id="https://www.notion.so/52d9ba77745c40c18e9fd19964b9d402" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/52d9ba77745c40c18e9fd19964b9d402"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">5. 渲染节点</span></span></h2><div id="https://www.notion.so/6bee45b8f88547fcbd5bceb5b042f839" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。</span></span></p></div><div id="https://www.notion.so/a8ff7de6793146dc821ccc7f62fec7a1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/482302f1d9f847618ad1411564cc102f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/482302f1d9f847618ad1411564cc102f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">渲染流程</span></span></h1><h2 id="https://www.notion.so/a82b58fbd5d54a38b7b0b51bee6c1e53" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/a82b58fbd5d54a38b7b0b51bee6c1e53"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">1. DOM+CSSOM ⇒ 布局树</span></span></h2><div id="https://www.notion.so/e37629303850474a8d1aee46c84c7413" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa0bcee50-f9b9-4ce3-a604-90695d14aaff%2FUntitled.png?width=1142&amp;table=block&amp;id=e3762930-3850-474a-8d1a-ee46c84c7413"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa0bcee50-f9b9-4ce3-a604-90695d14aaff%2FUntitled.png?width=1142&amp;table=block&amp;id=e3762930-3850-474a-8d1a-ee46c84c7413" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/b738730426c345118f5d14a293252d70" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">为了构建布局树，浏览器大体上完成了下面这些工作：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/5eb6ca8710d64110ad31e41d254ae332" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；</span></span></li><li id="https://www.notion.so/0e27d504e0bb4bdda455e8bbfce24503" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。</span></span></li></ul><div id="https://www.notion.so/580a81a7c5714cc3b9f17b9497592385" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/55dca33beda44a1d85f9cb1eca96bc85" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/55dca33beda44a1d85f9cb1eca96bc85"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2. 布局计算</strong></span></span></h2><div id="https://www.notion.so/127c03c09cf6437ba3fa1e35bdf4265c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">现在我们有了一棵完整的布局树。那么接下来，就要</span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorRed"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">计算布局树节点的坐标位置</strong></mark></span><span class="SemanticString">了。布局的计算过程非常复杂，我们这里先跳过不讲，等到后面章节中我再做详细的介绍。</span></span></p></div><div id="https://www.notion.so/bf35efcd42ea4e9c828828e547f13ff6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</span></span></p></div><div id="https://www.notion.so/9c8f61d8976743b9965528ef957a0f8d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/f8116b10fc8e4312a109b4b54fa18d6d" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/f8116b10fc8e4312a109b4b54fa18d6d"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">3. 分层</span></span></h2><div id="https://www.notion.so/eec4049595b44725ac4de32a76a63a9e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树</strong></span><span class="SemanticString">（LayerTree）。</span></span></p></div><div id="https://www.notion.so/9416592a869c453ba771778e95dffdea" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/f8adfc18cf1f45328d1e0279d6757f14" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F187891f5-9a3f-4d04-8528-3ba3d6ac4532%2FUntitled.png?width=1142&amp;table=block&amp;id=f8adfc18-cf1f-4532-8d1e-0279d6757f14"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F187891f5-9a3f-4d04-8528-3ba3d6ac4532%2FUntitled.png?width=1142&amp;table=block&amp;id=f8adfc18-cf1f-4532-8d1e-0279d6757f14" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/81ec2ff4ef274e23923301dff6b1ce05" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/ba02779206c548d7be67409396a72ad6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</span></span></p></div><div id="https://www.notion.so/a2a57bc4638b424ea831ec9ee890bba3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">第一点，拥有层叠上下文属性的元素会被提升为单独的一层。</strong></span></span></p></div><div id="https://www.notion.so/e415518686114c7ca959b2f79868c3a4" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F61f6c64a-24b2-441a-b4d9-93e7cecd34eb%2FUntitled.png?width=1142&amp;table=block&amp;id=e4155186-8611-4c7c-a959-b2f79868c3a4"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F61f6c64a-24b2-441a-b4d9-93e7cecd34eb%2FUntitled.png?width=1142&amp;table=block&amp;id=e4155186-8611-4c7c-a959-b2f79868c3a4" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/ef4f34d027054518b4a437d65b4571e6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。</span></span></p></div><div id="https://www.notion.so/508324cc581a41e5867441225cbd093f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">第二点，需要剪裁（clip）的地方也会被创建为图层。</strong></span></span></p></div><div id="https://www.notion.so/c9de74f8d0b2441b80f88686e21a87c3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在这里我们把 div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域。</span></span></p></div><div id="https://www.notion.so/3e028cd3ef3a4360a76b3dc591cb12d4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：</span></span></p></div><div id="https://www.notion.so/2061706ae0b74d20a091f7820d51279f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/7d1af5eba35e460290978132aba2cf8d" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/7d1af5eba35e460290978132aba2cf8d"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">图层绘制</span></span></h3><div id="https://www.notion.so/0602f0526c4d4a3bb80ca12620105731" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">渲染引擎会把一个图层的绘制拆分成很多小的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">绘制指令</strong></span><span class="SemanticString">，然后再把这些指令按照顺序组成一个待绘制列表</span></span></p></div><div id="https://www.notion.so/4f1076b937934b0badb814fe94cd8d58" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1de2a870-5cea-4aaa-8053-0dff0fd56f97%2FUntitled.png?width=1142&amp;table=block&amp;id=4f1076b9-3793-4b0b-adb8-14fe94cd8d58"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1de2a870-5cea-4aaa-8053-0dff0fd56f97%2FUntitled.png?width=1142&amp;table=block&amp;id=4f1076b9-3793-4b0b-adb8-14fe94cd8d58" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h3 id="https://www.notion.so/b16e4ef05b1c47ed86d2116ac4777993" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/b16e4ef05b1c47ed86d2116ac4777993"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">栅格化（raster）操作</strong></span></span></h3><div id="https://www.notion.so/8d39e32b0e394084ba8b14490883676b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">合成线程</strong></span><span class="SemanticString">来完成的</span></span></p></div><div id="https://www.notion.so/2ed88e770fe94f388c4be85632f199e1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当图层的绘制列表准备好之后，主线程会把该绘制列表</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">提交（commit）</strong></span><span class="SemanticString">给合成线程</span></span></p></div><div id="https://www.notion.so/37fc52d2d19149198ffe54ed652fd0fe" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorRed"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">视口</strong></mark></span><span class="SemanticString">：通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">视口</strong></span><span class="SemanticString">（viewport）。</span></span></p></div><div id="https://www.notion.so/fd0bdbef733a4282909253cc5b4e09e3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</span></span></p></div><div id="https://www.notion.so/e60c8ce6652040288dd11182836618fc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">基于这个原因，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">合成线程会将图层划分为图块（tile）</strong></span><span class="SemanticString">，这些图块的大小通常是 256x256 或者 512x512，如下图所示：</span></span></p></div><div id="https://www.notion.so/b5bfc55c9707449bb4ce311d8bd89ee9" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F55e3faa6-258b-4c58-8594-eb55894d7bb1%2FUntitled.png?width=1142&amp;table=block&amp;id=b5bfc55c-9707-449b-b4ce-311d8bd89ee9"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F55e3faa6-258b-4c58-8594-eb55894d7bb1%2FUntitled.png?width=1142&amp;table=block&amp;id=b5bfc55c-9707-449b-b4ce-311d8bd89ee9" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/d668281af4634451814f249d4a25265b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图</strong></span><span class="SemanticString">。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</span></span></p></div><div id="https://www.notion.so/ed003d4264f0450f9ab6a75da4c82615" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F29f9f196-3097-402c-b386-9efa46f90a40%2FUntitled.png?width=1142&amp;table=block&amp;id=ed003d42-64f0-450f-9ab6-a75da4c82615"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F29f9f196-3097-402c-b386-9efa46f90a40%2FUntitled.png?width=1142&amp;table=block&amp;id=ed003d42-64f0-450f-9ab6-a75da4c82615" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/0a77d6655cca425d9fb793db02c07efe" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">快速栅格化</strong></span><span class="SemanticString">，或者 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">GPU 栅格化</strong></span><span class="SemanticString">，生成的位图被保存在 GPU 内存中。</span></span></p></div><div id="https://www.notion.so/64a606fad8544b51b2ad54489e84f577" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。</span></span></p></div><div id="https://www.notion.so/1d382b899efb410e8f037ec01405aaa8" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff16d6cd4-9014-44be-bc42-c99a9e13d227%2FUntitled.png?width=1142&amp;table=block&amp;id=1d382b89-9efb-410e-8f03-7ec01405aaa8"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff16d6cd4-9014-44be-bc42-c99a9e13d227%2FUntitled.png?width=1142&amp;table=block&amp;id=1d382b89-9efb-410e-8f03-7ec01405aaa8" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h3 id="https://www.notion.so/54e23081f8ec406abeef114706dfa04e" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/54e23081f8ec406abeef114706dfa04e"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">合成和显示</strong></span></span></h3><div id="https://www.notion.so/8734f4494f104f84899e88959e3fcd08" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</span></span></p></div><div id="https://www.notion.so/7f3b5e98b2064a55a709fc03e64ae199" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</span></span></p></div><div id="https://www.notion.so/c533a26834014638b8250db5342ba7b1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。</span></span></p></div><div id="https://www.notion.so/d2ec89aaa0da4110af92d99595c20859" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/90c60d31db8544c1908c8aea43eae617" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/90c60d31db8544c1908c8aea43eae617"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">渲染流水线图示</span></span></h3><div id="https://www.notion.so/251b833f3dfa47f2b3b906542aa71deb" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb78e7d89-fb35-49f8-afba-9431c98fe828%2FUntitled.png?width=1142&amp;table=block&amp;id=251b833f-3dfa-47f2-b3b9-06542aa71deb"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb78e7d89-fb35-49f8-afba-9431c98fe828%2FUntitled.png?width=1142&amp;table=block&amp;id=251b833f-3dfa-47f2-b3b9-06542aa71deb" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/6056c93c61ca4e41b69d51dff5178b2c" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">渲染进程将 HTML 内容转换为能够读懂的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">DOM 树</strong></span><span class="SemanticString">结构。</span></span></li><li id="https://www.notion.so/d24122137fd14d8a8d8a686a8d692e57" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">渲染引擎将 CSS 样式表转化为浏览器可以理解的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">styleSheets</strong></span><span class="SemanticString">，计算出 DOM 节点的样式。</span></span></li><li id="https://www.notion.so/f4cf57f385ef4d2d8accf37952c5da7c" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">创建</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">布局树</strong></span><span class="SemanticString">，并计算元素的布局信息。</span></span></li><li id="https://www.notion.so/0c434f0a8c234366a6b8898efaad1efc" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">对布局树进行分层，并生成</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">分层树</strong></span><span class="SemanticString">。</span></span></li><li id="https://www.notion.so/3560c2a3b02d4a5f88bdfd3f25f2e32e" class="NumberedList" value="5"><span class="SemanticStringArray"><span class="SemanticString">为每个图层生成</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">绘制列表</strong></span><span class="SemanticString">，并将其提交到合成线程。</span></span></li><li id="https://www.notion.so/1dfb84b45501481fbea154e112816ad1" class="NumberedList" value="6"><span class="SemanticStringArray"><span class="SemanticString">合成线程将图层分成</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">图块</strong></span><span class="SemanticString">，并在</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">光栅化线程池</strong></span><span class="SemanticString">中将图块转换成位图。</span></span></li><li id="https://www.notion.so/046164c5bbc142ad8ccb0ced42f55e13" class="NumberedList" value="7"><span class="SemanticStringArray"><span class="SemanticString">合成线程发送绘制图块命令</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">DrawQuad</strong></span><span class="SemanticString">给浏览器进程。</span></span></li><li id="https://www.notion.so/42b90c52a9454d329f19dad5bec79815" class="NumberedList" value="8"><span class="SemanticStringArray"><span class="SemanticString">浏览器进程根据 DrawQuad 消息</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">生成页面</strong></span><span class="SemanticString">，并</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">显示</strong></span><span class="SemanticString">到显示器上。</span></span></li></ol><div id="https://www.notion.so/7bfdc5da6fa24dc9813b677cd2c63819" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/26087379b32d4f34b3063eb4b217e955" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/bb361929eba5423c8f3871191be76b46" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/bb361929eba5423c8f3871191be76b46"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1. 更新了元素的几何属性（重排）</strong></span></span></h3><div id="https://www.notion.so/2426eb01d22c4e25932f03498afdd6e2" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F01f2428b-71c3-4290-a38f-17e5335ee3e3%2FUntitled.png?width=1142&amp;table=block&amp;id=2426eb01-d22c-4e25-932f-03498afdd6e2"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F01f2428b-71c3-4290-a38f-17e5335ee3e3%2FUntitled.png?width=1142&amp;table=block&amp;id=2426eb01-d22c-4e25-932f-03498afdd6e2" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/d653ce7eb1b5497caec03fd01590f45f" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/b08cb53e73d14adc88c29b2ec3572d63" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">重排</strong></span><span class="SemanticString">。无疑，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">重排需要更新完整的渲染流水线，所以开销也是最大的</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/1a171d9424af4b9785e6746c71d5adcf" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/6b39d6c3a6874478992b5c1f175d7199" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/6b39d6c3a6874478992b5c1f175d7199"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">2. 更新元素的绘制属性（重绘）</span></span></h3><div id="https://www.notion.so/63ce32df1cbc4e63bc8f320e47b10d96" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F85280892-a35a-45e1-8760-fbe1d82e0fce%2FUntitled.png?width=1142&amp;table=block&amp;id=63ce32df-1cbc-4e63-bc8f-320e47b10d96"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F85280892-a35a-45e1-8760-fbe1d82e0fce%2FUntitled.png?width=1142&amp;table=block&amp;id=63ce32df-1cbc-4e63-bc8f-320e47b10d96" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/2f3eaf74325649769d26b4c28c57975b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">相较于重排操作，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些</strong></span><span class="SemanticString">。</span></span></p></div><h3 id="https://www.notion.so/fa5cae3ebd9c45d496b8b1ab6f7f3de3" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/fa5cae3ebd9c45d496b8b1ab6f7f3de3"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">3. 直接合成阶段</strong></span></span></h3><div id="https://www.notion.so/cb7f58d3b6c043f5ae8af110accc572e" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1ddba202-8149-4637-bbdc-8112a054fa9d%2FUntitled.png?width=1142&amp;table=block&amp;id=cb7f58d3-b6c0-43f5-ae8a-f110accc572e"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1ddba202-8149-4637-bbdc-8112a054fa9d%2FUntitled.png?width=1142&amp;table=block&amp;id=cb7f58d3-b6c0-43f5-ae8a-f110accc572e" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/75833ecc558b42888ee6c7f194873ce6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">相对于重绘和重排，合成能大大提升绘制效率</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/4e70ee02e0dd4a2fbbea3f35319ba953" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/e9c7e47466f94115aefa8e7b3a49e40d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/93fa44dde62c493cbcbcdb2371eda53a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/d5c85aeec478467896a11a13e84c5df4" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/d5c85aeec478467896a11a13e84c5df4"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">作用域</span></span></h1><div id="https://www.notion.so/f93a30552e674cbd8857957bded65934" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</strong></span></span></p></div><div id="https://www.notion.so/edeaca9c1dce4279b6f27293b9074cca" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 ES6 之前，ES 的作用域只有两种：</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">全局作用域</code></span><span class="SemanticString">和</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">函数作用域</code></span><span class="SemanticString">。</span></span></p></div><h2 id="https://www.notion.so/67202992e85042ec922a4c94729b63d9" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/67202992e85042ec922a4c94729b63d9"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">块级作用域</span></span></h2><div id="https://www.notion.so/3a2f39b4ba844b01929bf142b1a31e69" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">ES6之后支持了</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">块级作用域</code></span><span class="SemanticString">，块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。</span></span></p></div><pre id="https://www.notion.so/282c8d8205374a77b71008edfa50d544" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token comment">//if 块</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
 
<span class="token comment">//while 块</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
 
<span class="token comment">// 函数块</span>
function <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
 
<span class="token comment">//for 循环块</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
 
<span class="token comment">// 单独一个块</span>
<span class="token punctuation">{</span><span class="token punctuation">}</span></span></span></span></code></pre><div id="https://www.notion.so/f37ecc3ec8f245b6b3338d3927606ec0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/ed79aa094184466ab6869a18ac5b1e8c" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/ed79aa094184466ab6869a18ac5b1e8c"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">变量提升</strong></span></span></h2><div id="https://www.notion.so/01f0758059ac4f4bb222f98936b98c97" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">没有块级作用域，直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。</span></span></p></div><h3 id="https://www.notion.so/52862e0e976b4b32b55ea5c4f8a5ecaa" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/52862e0e976b4b32b55ea5c4f8a5ecaa"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1. 变量容易在不被察觉的情况下被覆盖掉</strong></span></span></h3><pre id="https://www.notion.so/c39ad8a348834b40af05ffba3438a9e6" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">var</span> myname <span class="token operator">=</span> <span class="token string">" 极客时间 "</span>
function <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myname<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">var</span> myname <span class="token operator">=</span> <span class="token string">" 极客邦 "</span>
  <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myname<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "极客邦"</span>
<span class="token punctuation">}</span>
<span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span></span></code></pre><h3 id="https://www.notion.so/1bddde5464a14118ae5eee3ad5700f94" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/1bddde5464a14118ae5eee3ad5700f94"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2. 本应销毁的变量没有被销毁</strong></span></span></h3><pre id="https://www.notion.so/6bef02a69a6a4c2ab3059774c23b7b91" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>function <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 块级作用域结束后，i需要被消除掉，但是var没有做到</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span></span></code></pre><div id="https://www.notion.so/080d535c303140eea7163d3b615548c7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/02e5c11033ce4d3380e8bcf4ae794f99" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/a128b80587ad47bb8f874031c3706d9e" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/a128b80587ad47bb8f874031c3706d9e"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">解决变量提升 - let const</span></span></h2><h3 id="https://www.notion.so/dba8f1b1e9e2458d98779c7baeb02829" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/dba8f1b1e9e2458d98779c7baeb02829"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">js如何支持块级作用域</span></span></h3><div id="https://www.notion.so/26843a2ced3c4d31bac4e8f8f1965744" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9b98177e-3fad-44dd-a64f-de75081ca7aa%2FUntitled.png?width=1142&amp;table=block&amp;id=26843a2c-ed3c-4d31-bac4-e8f8f1965744"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9b98177e-3fad-44dd-a64f-de75081ca7aa%2FUntitled.png?width=1142&amp;table=block&amp;id=26843a2c-ed3c-4d31-bac4-e8f8f1965744" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/56d0c8be112a4eb68ac3a2de9d912369" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">在词法环境内部，维护了一个小型栈结构，用来压入</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">let/const</code></span><span class="SemanticString">变量</span></span></li><li id="https://www.notion.so/202649728d254ce991d74a08f1f20637" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">一个函数内部的所有可以编译到的变量都会在编译阶段放入对应环境中</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/1f2db4b7a8894291921ff790618a21cb" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">var放在变量环境（VO/VE），let const放在词法环境中</span></span></li></ul></li><li id="https://www.notion.so/904ab9516d2640cba62702e7e5b6bd07" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">执行函数时遇到块级作用域，边执行边将let/const变量添加到词法环境中</span></span></li><li id="https://www.notion.so/37a4fe9c9faf416c886eddac90f2fe13" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">输出时先找词法环境中所有内容，找不到再去变量环境找</span></span></li></ul><div id="https://www.notion.so/cdb7503b3d2748809283b92a95d34f82" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbc54ceef-15d9-488a-b33e-9f91f34a3032%2FUntitled.png?width=1142&amp;table=block&amp;id=cdb7503b-3d27-4880-9283-b92a95d34f82"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbc54ceef-15d9-488a-b33e-9f91f34a3032%2FUntitled.png?width=1142&amp;table=block&amp;id=cdb7503b-3d27-4880-9283-b92a95d34f82" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/c8f52fa9e52b476885ae47a4877f37f7" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">执行foo函数，将foo的函数执行上下文压入调用栈中</span></span></li><li id="https://www.notion.so/d0a1f3a0dbb74d57942c29f8ebdf7f1e" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">解析foo函数，生成AST语法树的同时生成AO</span></span></li><li id="https://www.notion.so/93bfc33f5b7148d6ab60491bd84e5c0c" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">foo函数的变量环境和词法环境中的变量准备好</span></span><ol class="NumberedListWrapper"><li id="https://www.notion.so/9cbc305bd7ad4ea583d9e21fb8bcc1ad" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">此时变量环境中有a c，词法环境有b</span></span></li><li id="https://www.notion.so/adccc2ab33024abab342c7e57b22b4c5" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">没有d的原因在于：函数内的块中let只有当块执行的时候才会被追加进词法环境</span></span></li></ol></li><li id="https://www.notion.so/a1eef82dc0974ca29848bb8ee71b5cf6" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">执行到块内，追加词法环境变量（当块执行完就会被弹出栈）</span></span></li><li id="https://www.notion.so/8989407706c640cd8b43ef08dda60e7d" class="NumberedList" value="5"><span class="SemanticStringArray"><span class="SemanticString">执行输出a，先找词法所有，后找变量环境</span></span></li><li id="https://www.notion.so/43407918a8534ae8bf3022154076c55f" class="NumberedList" value="6"><span class="SemanticStringArray"><span class="SemanticString">执行完块，d和b弹出栈</span></span></li></ol><div id="https://www.notion.so/516a88014acb44c4a73cbd717adaff86" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/7b51a5dc8aac4571a08da6742cbcfd87" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/7b51a5dc8aac4571a08da6742cbcfd87"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">暂时性死区</span></span></h3><pre id="https://www.notion.so/d45b75b9e95d49c1997448990ac448e7" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>let myname<span class="token operator">=</span> <span class="token char">'极客时间'</span>
<span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myname<span class="token punctuation">)</span> <span class="token comment">// 报错</span>
  let myname<span class="token operator">=</span> <span class="token char">'极客邦'</span>
<span class="token punctuation">}</span></span></span></span></code></pre><div id="https://www.notion.so/dd1066d068e44839bf072b9520135fbd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">ES6 中有明确的规定：如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。想要获取这些变量，必须执行到声明变量语句之后才行</span></span></p></div><div id="https://www.notion.so/ace63ce0a8f64100b56915f5c8afc061" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/f35e024b461142b5968b60ca50b253e5" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/f35e024b461142b5968b60ca50b253e5"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">作用域链和闭包</span></span></h1><h2 id="https://www.notion.so/9081ae16a4674b04a101aaebc9863670" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/9081ae16a4674b04a101aaebc9863670"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">作用域链</span></span></h2><div id="https://www.notion.so/37f6578f40144e8db2a4623ffa1266ad" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果当前作用域没有需要用到的变量，那么会查找当前作用域的outer，一直到全局作用域</span></span></p></div><h3 id="https://www.notion.so/68475f6dd58c452f84f55e8f0a142687" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/68475f6dd58c452f84f55e8f0a142687"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">词法作用域</span></span></h3><div id="https://www.notion.so/9ccf8801ccef42b3ab3bb5ab9211d9e7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，</span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorRed"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">与函数怎么调用没关系</strong></mark></span></span></p></div><div id="https://www.notion.so/30784e367c944a428af5ec4496ef386b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">而作用域链是由词法作用域决定的，函数声明在哪，外面包含他的作用域就是他的父作用域</span></span></p></div><div id="https://www.notion.so/67057926dead44dcadb136c14b069b64" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/44e557c9d8a44341847b1e37e3cc0298" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0bf087a4-2018-4454-953e-6a50001b536a%2FUntitled.png?width=1142&amp;table=block&amp;id=44e557c9-d8a4-4341-847b-1e37e3cc0298"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0bf087a4-2018-4454-953e-6a50001b536a%2FUntitled.png?width=1142&amp;table=block&amp;id=44e557c9-d8a4-4341-847b-1e37e3cc0298" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/f6a559fbd2644ce082cb9c558d6d4994" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/7c1ed2e09ae942798769ea29f0206443" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/7c1ed2e09ae942798769ea29f0206443"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">闭包</span></span></h2><div id="https://www.notion.so/a369192ea5cc4a66936ab7f74b139b17" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">闭包是由于词法作用域的存在而存在的，内部作用域可以访问outer的变量，从而将其保存在当前作用域的闭包中</span></span></p></div><div id="https://www.notion.so/4d90c634d01244a7a64546004364079e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">比如将函数return了，那么函数里面用到的所有外部变量都会变成该函数的专属背包，不会被系统回收，永远跟着这个函数</span></span></p></div><div id="https://www.notion.so/815ee9f9d6c344f796012886643ee794" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/84f14b3b74754ed8a124a2364cce0000" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/84f14b3b74754ed8a124a2364cce0000"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">闭包的回收</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/a19b02c3a6cc4601af3ac61a6e54d1b8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">全局函数的闭包一直存在直到页面结束，局部变量引用的函数的闭包在该变量释放后释放</span></span></li><li id="https://www.notion.so/66b4f7d0baa946e9a7ce7a0129f72c77" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">JS引擎的垃圾回收机制</span></span></li></ul><div id="https://www.notion.so/199b5a5cc16247c9979f0d9c5e1e6abb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/652b884268c44be9aff79e3e4c2a4dac" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/652b884268c44be9aff79e3e4c2a4dac"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">输出什么？触发闭包了吗？</span></span></h3><pre id="https://www.notion.so/79cdb7a2acd6405899fb239adbd676ab" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span>
    myName<span class="token operator">:</span> <span class="token string">"time.geekbang.com"</span><span class="token punctuation">,</span>
    printName<span class="token operator">:</span> function <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myName<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
function <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    let myName <span class="token operator">=</span> <span class="token string">" 极客时间 "</span>
    <span class="token keyword">return</span> bar<span class="token punctuation">.</span>printName
<span class="token punctuation">}</span>
let myName <span class="token operator">=</span> <span class="token string">" 极客邦 "</span>
let _printName <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">_printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
bar<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span></span></code></pre><ul class="BulletedListWrapper"><li id="https://www.notion.so/0b30b9f6a3aa4e9fa0d352bfddc49847" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">没触发闭包</span></span></li><li id="https://www.notion.so/dd1bd1ad3f8f4a4bb535163ed1751cd5" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">bar是一个对象，不是函数，printName的词法作用域是全局作用域</span></span></li><li id="https://www.notion.so/171181881e404a2d9a059034306df2b5" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">foo返回的是一个函数定义的变量，不涉及闭包</span></span></li></ul><div id="https://www.notion.so/e9381229be734dc7bcc28ab386956e85" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/0ae9318352f743ea816a2948d7708962" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">本例与上例不同，触发了闭包</span></span></p></div><pre id="https://www.notion.so/117494435cea41a991a2a92d89f8b0c6" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"window"</span>
<span class="token keyword">function</span> <span class="token function">bar1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'bar1'</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> <span class="token function-variable function">printName1</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> printName1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> _printName1 <span class="token operator">=</span> <span class="token function">bar1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">_printName1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span></span></code></pre><div id="https://www.notion.so/a25d0a3cbc18485783bd12fb62d7c236" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/6b1c94eaca8d46ea9a6260548d82eca4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/5a6a32f1970645f0bd3bc831c266a518" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/5a6a32f1970645f0bd3bc831c266a518"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">this</span></span></h1><div id="https://www.notion.so/d1c008affe464b719f9a4c2f5c630344" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff4a5ac46-b97a-4186-847b-f5a83f33e1bd%2FUntitled.png?width=864&amp;table=block&amp;id=d1c008af-fe46-4b71-9f9a-4c2f5c630344"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff4a5ac46-b97a-4186-847b-f5a83f33e1bd%2FUntitled.png?width=864&amp;table=block&amp;id=d1c008af-fe46-4b71-9f9a-4c2f5c630344" style="width:864px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/e7b8cc4608eb4bc6b53bdd6a82f7da1a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/f7bbce32145c41ce8be53950837df96b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/66a00235d03a4da6adb619fadf21018a" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/66a00235d03a4da6adb619fadf21018a"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">V8引擎工作原理</span></span></h1><h2 id="https://www.notion.so/b8fb3c659c98415482538fc184cd6d29" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/b8fb3c659c98415482538fc184cd6d29"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">内存如何存储数据</span></span></h2><div id="https://www.notion.so/8473dfce4f2b434984eaba6274581d28" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/e9b8b1b6410743469ddcf05aff8a73d3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">为什么不所有数据都存在栈中呢？</span></span></p></div><div id="https://www.notion.so/e41f90b9764043ff880e5a8a10ae2c64" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">因为 JavaScript 引擎需要</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorRed">用栈来维护程序执行期间上下文的状态</mark></strong></span><span class="SemanticString">，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。</span></span></p></div><div id="https://www.notion.so/4c44ba449b854a74a3fda311a39b59f1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">比如下图中foo函数执行完毕，指针下移到上个执行上下文的</span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorRed"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">地址</strong></mark></span><span class="SemanticString">，就可以回收foo函数的空间</span></span></p></div><div id="https://www.notion.so/32afae0bd45d4548b552d8aa2a73b288" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe62969ee-4d7b-4e4c-bc05-9b26e0ea5c6a%2FUntitled.png?width=1142&amp;table=block&amp;id=32afae0b-d45d-4548-b552-d8aa2a73b288"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe62969ee-4d7b-4e4c-bc05-9b26e0ea5c6a%2FUntitled.png?width=1142&amp;table=block&amp;id=32afae0b-d45d-4548-b552-d8aa2a73b288" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/b2b766f76f0e465d96d1ccfb96c28776" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/9b249b6d540443f4a127930ccaec0693" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">栈空间都不会设置太大，主要用来存放一些原始类型</strong></span></span></p></div><div id="https://www.notion.so/19ff4f35253f4c3aa9519fdddb60940e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">堆空间很大，存放引用数据类型</strong></span><span class="SemanticString">，不过缺点是分配内存和回收内存都会占用一定的时间。</span></span></p></div><div id="https://www.notion.so/371b4160654245228d2f4a7d8e909f73" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">原始类型的赋值会完整复制变量值，而引用类型的赋值是</strong></span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorRed"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">复制引用地址</strong></mark></span><span class="SemanticString">。所以修改一个另一个也会变，因为他们指向同一个堆空间对象</span></span></p></div><div id="https://www.notion.so/49292a05bcbe47ed80092b44a99b7b12" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/20b3012aa7874e209e6dcae304181716" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/20b3012aa7874e209e6dcae304181716"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">再谈闭包</span></span></h3><pre id="https://www.notion.so/1c552ab6a286453d9d93f4d01b6cda31" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> myName <span class="token operator">=</span> <span class="token string">" 极客时间 "</span>
    <span class="token keyword">let</span> test1 <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">const</span> test2 <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token keyword">var</span> innerBar <span class="token operator">=</span> <span class="token punctuation">{</span> 
        <span class="token function-variable function">setName</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newName</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            myName <span class="token operator">=</span> newName
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function-variable function">getName</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test1<span class="token punctuation">)</span>
            <span class="token keyword">return</span> myName
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> innerBar
<span class="token punctuation">}</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
bar<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">" 极客邦 "</span><span class="token punctuation">)</span>
bar<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></span></code></pre><div id="https://www.notion.so/2925281701b540c7bc29fa0a85637689" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当执行这段代码的时候，你应该有过这样的分析：由于变量 myName、test1、test2 都是原始类型数据，所以在执行 foo 函数的时候，它们会被压入到调用栈中；当 foo 函数执行结束之后，调用栈中 foo 函数的执行上下文会被销毁，其内部变量 myName、test1、test2 也应该一同被销毁。</span></span></p></div><div id="https://www.notion.so/8887ef383e0f48609acfd3deae60c620" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">但是当 foo 函数的执行上下文销毁时，由于 foo 函数产生了闭包，所以变量 myName 和 test1 并没有被销毁，而是保存在内存中，那么应该如何解释这个现象呢？</span></span></p></div><div id="https://www.notion.so/1e9674e63f92421f8a6c99aba84b671d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/01e2d48feb6746b38f3b60f77aa182ad" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">当 JavaScript 引擎执行到 foo 函数时，首先会</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">编译</strong></span><span class="SemanticString">，并</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">创建一个空执行上下文</strong></span><span class="SemanticString">。</span></span></li><li id="https://www.notion.so/6bd7be73faa54899acb68354c1c859df" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">在编译过程中，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">遇到内部函数</strong></span><span class="SemanticString"> setName，JavaScript 引擎还要对内部函数做一次</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">快速的词法扫描</strong></span><span class="SemanticString">，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在</span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorRed"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">堆空间创建闭包</strong></mark></span><span class="SemanticString">，即一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。</span></span></li><li id="https://www.notion.so/a800fc9bd5994939a567ce6f6e66ceae" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。</span></span></li><li id="https://www.notion.so/505f59ebfbd245449d95cdecd10c293f" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。</span></span></li></ol><div id="https://www.notion.so/0c62aa01fd2544c1b895ee18295bd3e5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">画出执行到 foo 函数中“return innerBar”语句时的调用栈状态，如下图所示：</span></span></p></div><div id="https://www.notion.so/2ac5cc2f250e4b1da42d256f3fd020c4" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F032f3fc1-ef7a-47e1-abe5-eeb5979a9ce0%2FUntitled.png?width=1142&amp;table=block&amp;id=2ac5cc2f-250e-4b1d-a42d-256f3fd020c4"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F032f3fc1-ef7a-47e1-abe5-eeb5979a9ce0%2FUntitled.png?width=1142&amp;table=block&amp;id=2ac5cc2f-250e-4b1d-a42d-256f3fd020c4" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/d7554f895bda40a6b704f0bbd66ec42d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“clourse(foo)”对象，所以即使 foo 函数退出了，“clourse(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">调用</strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><code class="SemanticString__Fragment SemanticString__Fragment--Code">bar.setName</code></strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">或者</strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><code class="SemanticString__Fragment SemanticString__Fragment--Code">bar.getName</code></strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">时</strong></span><span class="SemanticString">，</span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorOrange"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">创建的执行上下文中就包含了“clourse(foo)”</strong></mark></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/1a935a6d0f084358a15b76b95d03e1a2" class="ColorfulBlock ColorfulBlock--BgOrange Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。</span></span></p></div><div id="https://www.notion.so/029cf8c095a9495b840e6f79f5120c83" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/214ec3ecaa784b9493e187ed0a19cdc2" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/214ec3ecaa784b9493e187ed0a19cdc2"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">垃圾回收</span></span></h2><div id="https://www.notion.so/40c2ddf6b8b041c48d16930741437ce3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在调用栈中，当一个函数执行结束之后，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">JavaScript 引擎会通过向下移动 ESP（记录当前执行状态的指针） 来销毁该函数保存在栈中的执行上下文</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/7a2ae2ff98114584a147281675ce5be2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了</strong></span><span class="SemanticString">。</span></span></p></div><h3 id="https://www.notion.so/26798fa4e78c46bba6b1cfcf90a15e8e" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/26798fa4e78c46bba6b1cfcf90a15e8e"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">代际假说</strong></span></span></h3><div id="https://www.notion.so/fa70cee6357448099e55418ed2b527d3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">代际假说有两个特点：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/30f2ba440ea34c578ee74c3bc7bf7d0f" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</span></span></li><li id="https://www.notion.so/787ef5ef29b24d2fb2532222c5ee7010" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">第二个是不死的对象，会活得更久。</span></span></li></ul><div id="https://www.notion.so/16a7540ca6054174a663caa6999abf23" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">V8 中会把堆分为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">新生代</strong></span><span class="SemanticString">和</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">老生代</strong></span><span class="SemanticString">两个区域，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/91bb3de6084a4b3c9884b5ce67e02b34" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">新生区容量小，老生区容量大</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/f3bcc59475984d019c8429ebb01cd038" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">副垃圾回收器，主要负责新生代的垃圾回收。</strong></span></span></li><li id="https://www.notion.so/8ebc6c845d914aca83a86721c467d96b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">主垃圾回收器，主要负责老生代的垃圾回收。</strong></span></span></li></ul><h3 id="https://www.notion.so/404e6f4d75a143d18ac32ac7f196632d" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/404e6f4d75a143d18ac32ac7f196632d"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">垃圾回收器的工作流程</strong></span></span></h3><div id="https://www.notion.so/ca1c2c998c1c48d1a15099bd013a2604" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</span></span></p></div><div id="https://www.notion.so/3ab8901e26f64fabb2eaec11e1635bef" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</span></span></p></div><div id="https://www.notion.so/e0791586feb34fa0a49b41f80a30d61a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">内存碎片</strong></span><span class="SemanticString">。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</span></span></p></div><div id="https://www.notion.so/92d008ec2fda487faaf654ded8c811dd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/22dd37a8d3334bfba6eda83a11d428d2" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/22dd37a8d3334bfba6eda83a11d428d2"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">副垃圾回收器</span></span></h3><div id="https://www.notion.so/2d53595806844ee7a379b92a8370b75e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</span></span></p></div><div id="https://www.notion.so/8497fb79dd6f4f5c9e242984423989cb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">新生代中用</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Scavenge 算法</strong></span><span class="SemanticString">来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：</span></span></p></div><div id="https://www.notion.so/d44b29c8e2654fac8201dde47c74ca06" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa9493284-e873-4484-bbe2-42c30ebd8060%2FUntitled.png?width=1142&amp;table=block&amp;id=d44b29c8-e265-4fac-8201-dde47c74ca06"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa9493284-e873-4484-bbe2-42c30ebd8060%2FUntitled.png?width=1142&amp;table=block&amp;id=d44b29c8-e265-4fac-8201-dde47c74ca06" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/cbaa32ea68ca47319143f8830bddd02a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</span></span></p></div><div id="https://www.notion.so/d5e86f1e7d1d4221a7b4961f5b3d35d6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</span></span></p></div><div id="https://www.notion.so/9ec617938c1842ea9281073ad300352a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/6391be05124b41f3b039d99b2d7144a9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">为了执行效率，一般新生区的空间会被设置得比较小</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/014af1da648d4e828144bb148cd26459" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了</span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorRed"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">对象晋升策略</strong></mark></span><span class="SemanticString">，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</span></span></p></div><div id="https://www.notion.so/9f6e5daf36bc4269874ab0ceedf36d0c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/5727bcfaaa1b415386580526311a1736" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/5727bcfaaa1b415386580526311a1736"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">主垃圾回收器</span></span></h3><div id="https://www.notion.so/0034aa02b5f54db3875a6a75cceafc99" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</span></span></p></div><div id="https://www.notion.so/2ca5ae74851444f6a33c1bb9624f7557" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">标记 - 清除（Mark-Sweep）</strong></span><span class="SemanticString">的算法进行垃圾回收的。</span></span></p></div><div id="https://www.notion.so/98c8d1892517452f95fda9f5d0c0b905" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">活动对象</strong></span><span class="SemanticString">，没有到达的元素就可以判断为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">垃圾数据</strong></span><span class="SemanticString">。</span></span></p></div><pre id="https://www.notion.so/bb3bf557010e4148bfed885d669925a7" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">" 极客邦 "</span><span class="token punctuation">}</span>
    <span class="token keyword">function</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token string">" 极客时间 "</span>
      <span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">" 极客时间 "</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span></span></code></pre><div id="https://www.notion.so/e82f8b19ed7a4ce38a0f79400f970019" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这段代码当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示：</span></span></p></div><div id="https://www.notion.so/c0ab8bf112024899aa156f64c6f641cf" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbb64f009-bd0b-406d-9613-352190954b1e%2FUntitled.png?width=1142&amp;table=block&amp;id=c0ab8bf1-1202-4899-aa15-6f64c6f641cf"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbb64f009-bd0b-406d-9613-352190954b1e%2FUntitled.png?width=1142&amp;table=block&amp;id=c0ab8bf1-1202-4899-aa15-6f64c6f641cf" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/d7b5839fd98f4ffd9af10bada81c693b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">从上图你可以大致看到垃圾数据的标记过程，当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。</span></span></p></div><div id="https://www.notion.so/d6cca36d2ddc49869f05af1a0e84403e" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fae43d2e2-dc0f-4d57-8a94-3e07a36692f9%2FUntitled.png?width=1142&amp;table=block&amp;id=d6cca36d-2ddc-4986-9f05-af1a0e84403e"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fae43d2e2-dc0f-4d57-8a94-3e07a36692f9%2FUntitled.png?width=1142&amp;table=block&amp;id=d6cca36d-2ddc-4986-9f05-af1a0e84403e" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/baa4561bd3694513bf2a04e39ecc7adc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">标记 - 整理（Mark-Compact）</strong></span><span class="SemanticString">，这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：</span></span></p></div><div id="https://www.notion.so/a7f0cea6f0804c51b8efa4aef25f9505" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3cd9921a-bd3b-418f-bba1-f68fc7057639%2FUntitled.png?width=1142&amp;table=block&amp;id=a7f0cea6-f080-4c51-b8ef-a4aef25f9505"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3cd9921a-bd3b-418f-bba1-f68fc7057639%2FUntitled.png?width=1142&amp;table=block&amp;id=a7f0cea6-f080-4c51-b8ef-a4aef25f9505" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h3 id="https://www.notion.so/b7047e12d2044129972e55428438c963" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/b7047e12d2044129972e55428438c963"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">全停顿</span></span></h3><div id="https://www.notion.so/f2308b34c86f4d838cdc5dcc83da4578" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">全停顿（Stop-The-World）</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/d3a2a97450184571b3d583abc59ce60f" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F598fc8fa-d380-407a-8a9e-aaf7a845a4a5%2FUntitled.png?width=1142&amp;table=block&amp;id=d3a2a974-5018-4571-b3d5-83abc59ce60f"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F598fc8fa-d380-407a-8a9e-aaf7a845a4a5%2FUntitled.png?width=1142&amp;table=block&amp;id=d3a2a974-5018-4571-b3d5-83abc59ce60f" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/2363b14bcc9c43b09fe7b5f1c590db8e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</span></span></p></div><div id="https://www.notion.so/2d5f0164281d4527a0d2d803667f6e4b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">增量标记（Incremental Marking）算法</strong></span><span class="SemanticString">。如下图所示：</span></span></p></div><div id="https://www.notion.so/7266078d68fe4493afd3b489e5cf9339" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd62ac7b4-67be-4e7b-a8e9-87f65caf15d3%2FUntitled.png?width=1142&amp;table=block&amp;id=7266078d-68fe-4493-afd3-b489e5cf9339"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd62ac7b4-67be-4e7b-a8e9-87f65caf15d3%2FUntitled.png?width=1142&amp;table=block&amp;id=7266078d-68fe-4493-afd3-b489e5cf9339" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/922cbc0305e541c6acfaae2a0557db0d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</span></span></p></div><div id="https://www.notion.so/451023171fbe4ad98989d6bb023dc37c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/ef01be5cf6e84563bf8c355ba0908741" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/ef01be5cf6e84563bf8c355ba0908741"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">你是如何判断 JavaScript 中内存泄漏的？如何避免泄漏？</span></span></h3><ol class="NumberedListWrapper"><li id="https://www.notion.so/923cd5ffa38e4a46a5ef3f449ad0bd51" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">意外全局变量</span></span><div id="https://www.notion.so/34e33950249d4fe981339e7c9ac297c5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">全局变量的生命周期最长，直到页面关闭前，它都存活着，所以全局变量上的内存一直都不会被回收</span></span></p></div><div id="https://www.notion.so/84f31707067f499cb1ee9cc66b551262" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当全局变量使用不当，没有及时回收（手动赋值 null），或者拼写错误等将某个变量挂载到全局变量时，也就发生内存泄漏了</span></span></p></div></li><li id="https://www.notion.so/d5930759c3f44decb6f53c689b000620" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">定时器</span></span><div id="https://www.notion.so/07108b4c28d1483fa3cf1cb49f3ec68e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">setTimeout 和 setInterval 是由浏览器专门线程来维护它的生命周期，所以当在某个页面使用了定时器，当该页面销毁时，没有手动去释放清理这些定时器的话，那么这些定时器还是存活着的</span></span></p></div><div id="https://www.notion.so/c3dce7b424df4fd0867103a7ae3753de" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当前页面的 js 里通过定时器注册了某个回调函数，而该回调函数内又持有当前页面某个变量或某些 DOM 元素时，就会导致即使页面销毁了，由于定时器持有该页面部分引用而造成页面无法正常被回收，从而导致内存泄漏了</span></span></p></div><div id="https://www.notion.so/750e0f1b968f4c2f9a35e259f358dd0a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果此时再次打开同个页面，内存中其实是有双份页面数据的，如果多次关闭、打开，那么内存泄漏会越来越严重</span></span></p></div></li></ol><div id="https://www.notion.so/4e2d49614ab8466c8715a21e68cb445c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/859ad76b1a144f94a77ef0a8969e2328" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/fdabaaa4cd97436e9e4cf1a1e7bec45a" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/fdabaaa4cd97436e9e4cf1a1e7bec45a"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">v8如何执行js代码</span></span></h2><h3 id="https://www.notion.so/859d9e37f4b248f69c18feb4bce5b807" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/859d9e37f4b248f69c18feb4bce5b807"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">编译器和解释器</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/b182face58e34d3bbdd4efa7ddca3603" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了</strong></span><span class="SemanticString">。比如 C/C++、GO 等都是编译型语言。</span></span></li><li id="https://www.notion.so/a8603c87c2fe493b94874161792e2c76" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行</strong></span><span class="SemanticString">。比如 Python、JavaScript 等都属于解释型语言。</span></span></li></ul><div id="https://www.notion.so/cc1dfe6cc1f64a22b2bfcf2d0b54d36c" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd2d84ef4-2a9f-4303-b5e0-a775a4d65089%2FUntitled.png?width=1142&amp;table=block&amp;id=cc1dfe6c-c1f6-4a22-b2bf-cf2d0b54d36c"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd2d84ef4-2a9f-4303-b5e0-a775a4d65089%2FUntitled.png?width=1142&amp;table=block&amp;id=cc1dfe6c-c1f6-4a22-b2bf-cf2d0b54d36c" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/186c6f3ee38043b5acbda179e6519854" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/b0feaeaa2d504371a341940fa91e99ce" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">V8执行代码流程图</span></span></p></div><div id="https://www.notion.so/bffa19680cc7438e8a3f1ebb7e0bc45d" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Faefd4425-4fee-464e-89f6-59d504641bdd%2FUntitled.png?width=1142&amp;table=block&amp;id=bffa1968-0cc7-438e-8a3f-1ebb7e0bc45d"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Faefd4425-4fee-464e-89f6-59d504641bdd%2FUntitled.png?width=1142&amp;table=block&amp;id=bffa1968-0cc7-438e-8a3f-1ebb7e0bc45d" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/c2a92b5b98914fc299703f93b69c1281" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">V8 在执行过程中既有</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">解释器 Ignition</strong></span><span class="SemanticString">，又有</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">编译器 TurboFan</strong></span></span></p></div><h3 id="https://www.notion.so/d78f1623bfb545a283f544ebe44552de" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/d78f1623bfb545a283f544ebe44552de"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">1. 生成抽象语法树AST和执行上下文</span></span></h3><div id="https://www.notion.so/f9193031586a4c9798efaea19593003a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">对于编译器或者解释器来说，它们可以理解的就是 AST 了。所以无论你使用的是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。</span></span></p></div><div id="https://www.notion.so/c4b1929dad514d649d5cf4b0cb2620ad" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/a4affcee96274f6181dbef8c04c92ed4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">将下面的js代码转化成AST</span></span></p></div><pre id="https://www.notion.so/ab410bd552134ef1a1373ad7e88cc655" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">var</span> myName <span class="token operator">=</span> <span class="token string">" 极客时间 "</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">23</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
myName <span class="token operator">=</span> <span class="token string">"geektime"</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span></span></code></pre><div id="https://www.notion.so/1d1d473f2f414f029625a488c6179775" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe8d1832c-8e76-46cf-aa86-841569211fd1%2FUntitled.png?width=1142&amp;table=block&amp;id=1d1d473f-2f41-4f02-9625-a488c6179775"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe8d1832c-8e76-46cf-aa86-841569211fd1%2FUntitled.png?width=1142&amp;table=block&amp;id=1d1d473f-2f41-4f02-9625-a488c6179775" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/b3c721adbc2f4c90b3c2ae5656f56ae1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</span></span></p></div><div id="https://www.notion.so/6581973d6a504fa6853583fceeb512de" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</span></span></p></div><div id="https://www.notion.so/0b7c9e821a8f48cbbfe1f3ef81b7fcf2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/6c912c664ee341578bd269d8ac046311" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">第一阶段是分词（tokenize），又称为词法分析</strong></span><span class="SemanticString">，其作用是将一行行的源码拆解成一个个 token。所谓</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">token</strong></span><span class="SemanticString">，指的是语法上不可能再分的、最小的单个字符或字符串。你可以参考下图来更好地理解什么 token。</span></span></p></div><div id="https://www.notion.so/1d38f11ea70243be97fe378486dcc921" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb2d9fe37-a5ca-4fc3-97c2-4b69a0c4f3b3%2FUntitled.png?width=1142&amp;table=block&amp;id=1d38f11e-a702-43be-97fe-378486dcc921"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb2d9fe37-a5ca-4fc3-97c2-4b69a0c4f3b3%2FUntitled.png?width=1142&amp;table=block&amp;id=1d38f11e-a702-43be-97fe-378486dcc921" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/45181fad12f648bba2d54aec2c89ce9f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">从图中可以看出，通过</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">var myName = “极客时间”</code></span><span class="SemanticString">简单地定义了一个变量，其中关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。</span></span></p></div><div id="https://www.notion.so/d86e81e962fe4cef90b1b709b7c55a05" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">第二阶段是解析（parse），又称为语法分析</strong></span><span class="SemanticString">，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</span></span></p></div><div id="https://www.notion.so/7832289b62914160a96881200c263d8b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/72face7c59934127b963cd7c5b43e438" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文</span></span></p></div><div id="https://www.notion.so/6d6b2ad611a94a8c96cb3ac9ba0d3273" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/032a8414f4af4277b0ed5036920788ab" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/032a8414f4af4277b0ed5036920788ab"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">2.生成字节码</span></span></h3><div id="https://www.notion.so/41b85fb75fe74daa9f5e48c05903704f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">解释器会根据AST生成字节码，并解释执行字节码</span></span></p></div><div id="https://www.notion.so/a518ba84f3734b7aa5140f2645d13806" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器</span></span></p></div><div id="https://www.notion.so/80c7aa845527440781685d95f3bedb02" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">什么是字节码呢？为什么引入字节码就能解决内存占用问题呢？</span></span></p></div><div id="https://www.notion.so/04bf8a92f08d4fba81dea45bfb6532bf" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</strong></span></span></p></div><div id="https://www.notion.so/eb959670552a40a38a7715c85ac29024" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F42153779-4d8a-4377-bd02-95eb2cd2e013%2FUntitled.png?width=1142&amp;table=block&amp;id=eb959670-552a-40a3-8a77-15c85ac29024"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F42153779-4d8a-4377-bd02-95eb2cd2e013%2FUntitled.png?width=1142&amp;table=block&amp;id=eb959670-552a-40a3-8a77-15c85ac29024" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/f148b8707cff4c8b89c7ca9de883b38d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。</span></span></p></div><div id="https://www.notion.so/142f1ae97eb44798a6ff4c98085611f6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/69729c91f23448bc95568d73b92f979f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/69729c91f23448bc95568d73b92f979f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">3.执行代码</span></span></h3><div id="https://www.notion.so/b6c35a6c82614841ba571b11fc1218e2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">生成字节码之后，接下来就要进入执行阶段了。</span></span></p></div><div id="https://www.notion.so/8869d87ce164462282cf551b32d98ac2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">热点代码</strong></span><span class="SemanticString">，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</span></span></p></div><blockquote id="https://www.notion.so/6da33503e8a442fabde002d652435bd2" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">V8 的解释器和编译器的取名也很有意思。解释器 Ignition 是点火器的意思，编译器 TurboFan 是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。</span></span></blockquote><div id="https://www.notion.so/905125cd1dd54fafb7e6c72facde870f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">字节码配合解释器和编译器是最近一段时间很火的技术，把这种技术称为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">即时编译（JIT）</strong></span></span></p></div><div id="https://www.notion.so/0f5bd1975dac4992a6c5b6ae9da370ef" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。</span></span></p></div><div id="https://www.notion.so/5f0fea61f8dc40cf9fe5e7dcde519d90" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff4990582-da56-4abe-b9d5-bcdd480f8102%2FUntitled.png?width=1142&amp;table=block&amp;id=5f0fea61-f8dc-40cf-9fe5-e7dcde519d90"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff4990582-da56-4abe-b9d5-bcdd480f8102%2FUntitled.png?width=1142&amp;table=block&amp;id=5f0fea61-f8dc-40cf-9fe5-e7dcde519d90" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/02cb1fc947234859aba8f94d31e77570" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></article>
  <footer class="Footer">
  <div>&copy; Notablog 2019-2021</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>